var tipuesearch = {"pages":[{"title":" Fortran 2018 examples ","text":"Fortran 2018 examples Developer Info Michael Hirsch Ph.D. SciVision, Inc.","tags":"home","loc":"index.html"},{"title":"contiguous.F90 – Fortran 2018 examples","text":"Contents Programs c Modules contig Source Code contiguous.F90 Source Code module contig use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 , i64 => int64 implicit none contains subroutine timestwo_contig ( x , contig ) real ( dp ), contiguous , intent ( inout ) :: x (:,:) logical , intent ( out ) :: contig #if ISCONTIG contig = is_contiguous ( x ) #endif x = 2 * x end subroutine timestwo_contig subroutine timestwo ( x , contig ) real ( dp ), intent ( inout ) :: x (:,:) logical , intent ( out ) :: contig #if ISCONTIG contig = is_contiguous ( x ) #endif x = 2 * x end subroutine timestwo end module contig program c use , intrinsic :: iso_fortran_env , only : compiler_version use contig implicit none integer , parameter :: N = 1000000 real ( dp ) :: x ( 2 , N ) = 1. integer ( i64 ) :: tic , toc , rate real ( dp ) :: t1 , t2 logical :: iscontig1 , iscontig2 !print *,compiler_version()  ! bug in flang 6 and PGI 18.10 call system_clock ( tic ) call timestwo ( x (:, 1 : N : 2 ), iscontig1 ) call system_clock ( toc , rate ) t1 = ( toc - tic ) / real ( rate , dp ) call system_clock ( tic ) call timestwo_contig ( x (:, 1 : N : 2 ), iscontig2 ) call system_clock ( toc , rate ) t2 = ( toc - tic ) / real ( rate , dp ) #if ISCONTIG print * , iscontig1 , ' contig: ' , t1 , ' sec.' print * , iscontig2 , ' contig: ' , t2 , ' sec.' #else print * , 'non-contig: ' , t1 , ' sec.' print * , 'contig: ' , t2 , ' sec.' #endif end program","tags":"","loc":"sourcefile/contiguous.f90.html"},{"title":"random.f90 – Fortran 2018 examples","text":"Files dependent on this one sourcefile~~random.f90~~AfferentGraph sourcefile~random.f90 random.f90 sourcefile~random_init_f2018.f90 random_init_f2018.f90 sourcefile~random_init_f2018.f90->sourcefile~random.f90 sourcefile~random_demo.f90 random_demo.f90 sourcefile~random_demo.f90->sourcefile~random.f90 sourcefile~random_init.f90 random_init.f90 sourcefile~random_init.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules random Source Code random.f90 Source Code module random implicit none interface module subroutine random_init () end subroutine end interface contains impure elemental integer function randint ( lo , hi ) integer , intent ( in ) :: lo , hi real :: r call random_number ( r ) randint = floor ( r * ( hi + 1 - lo )) + lo end function randint end module random","tags":"","loc":"sourcefile/random.f90.html"},{"title":"random_init_f2018.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~random_init_f2018.f90~~EfferentGraph sourcefile~random_init_f2018.f90 random_init_f2018.f90 sourcefile~random.f90 random.f90 sourcefile~random_init_f2018.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules randinit Source Code random_init_f2018.f90 Source Code submodule ( random ) randinit ! Fortran 2018 intrinsic random_init() intrinsic :: random_init () end submodule randinit","tags":"","loc":"sourcefile/random_init_f2018.f90.html"},{"title":"random_demo.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~random_demo.f90~~EfferentGraph sourcefile~random_demo.f90 random_demo.f90 sourcefile~random.f90 random.f90 sourcefile~random_demo.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs randominit Source Code random_demo.f90 Source Code program randominit use random , only : random_init real :: r integer :: i call random_init () print * , 'these two random number should not match if random_init is working' do i = 1 , 2 call random_number ( r ) print * , r enddo end program","tags":"","loc":"sourcefile/random_demo.f90.html"},{"title":"random_init.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~random_init.f90~~EfferentGraph sourcefile~random_init.f90 random_init.f90 sourcefile~random.f90 random.f90 sourcefile~random_init.f90->sourcefile~random.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules randinit Source Code random_init.f90 Source Code submodule ( random ) randinit use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none contains module procedure random_init ! NOTE: this subroutine is replaced by \"call random_init()\" intrinsic of Fortran 2018 integer :: n , u , ios , i integer , allocatable :: seed (:), check (:) call random_seed ( size = n ) allocate ( seed ( n ), check ( n )) open ( newunit = u , file = '/dev/urandom' , access = \"stream\" , & form = \"unformatted\" , action = \"read\" , status = \"old\" , iostat = ios ) if ( ios == 0 ) then read ( u , iostat = ios ) seed close ( u ) endif if ( ios /= 0 ) then write ( stderr , * ) 'falling back to internal random number generator' do i = 1 , n seed ( i ) = randint ( - 1073741823 , 1073741823 ) enddo endif call random_seed ( put = seed ) !print *,'seed: ',seed    ! for debug/test end procedure random_init end submodule randinit","tags":"","loc":"sourcefile/random_init.f90.html"},{"title":"pi2008.f90 – Fortran 2018 examples","text":"Contents Programs coarray_pi Source Code pi2008.f90 Source Code program coarray_pi ! implements calculation: !  \\pi = \\int&#94;1_{-1} \\frac{dx}{\\sqrt{1-x&#94;2}} use , intrinsic :: iso_fortran_env , only : dp => real64 , int64 , stderr => error_unit implicit none integer , parameter :: wp = dp real ( wp ), parameter :: x0 = - 1.0_wp , x1 = 1.0_wp real ( wp ), parameter :: pi = 4._wp * atan ( 1.0_wp ) real ( wp ) :: psum [ * ] ! this is a scalar coarray integer ( int64 ) :: rate , tic , toc real ( wp ) :: f , x , telaps , dx integer :: i , stat , im , Ni character ( 16 ) :: cbuf psum = 0._wp if ( command_argument_count () > 0 ) then call get_command_argument ( 1 , cbuf ) read ( cbuf , * , iostat = stat ) dx if ( stat /= 0 ) error stop 'must input real number for resolution e.g. 1e-6' else dx = 1 e - 6 endif Ni = int (( x1 - x0 ) / dx ) ! (1 - (-1)) / interval im = this_image () !--------------------------------- if ( im == 1 ) then call system_clock ( tic ) print '(A,I3)' , 'number of Fortran coarray images:' , num_images () print * , 'approximating pi in ' , Ni , ' steps.' end if !--------------------------------- do i = im , Ni - 1 , num_images () ! Each image works on a subset of the problem x = x0 + i * dx f = dx / sqrt ( 1.0_wp - x ** 2 ) psum = psum + f !    print *,x,f,psum end do ! --- co_sum is much simpler, but not working on ifort 2017 yet ! ---- alternative to Fortran 2018 co_sum for Fortran 2008 sync all if ( im == 1 ) then do i = 2 , num_images () psum = psum + psum [ i ] enddo endif if ( im == 1 ) then print * , 'pi:' , pi , '  iterated pi: ' , psum print '(A,E10.3)' , 'pi error' , pi - psum endif if ( im == 1 ) then call system_clock ( toc ) call system_clock ( count_rate = rate ) telaps = real (( toc - tic ), wp ) / rate print '(A,E10.3,A,I3,A)' , 'Elapsed wall clock time ' , telaps , ' seconds, using' , num_images (), ' images.' end if end program","tags":"","loc":"sourcefile/pi2008.f90.html"},{"title":"helloworld.f90 – Fortran 2018 examples","text":"Contents Programs helloworld Source Code helloworld.f90 Source Code program helloworld !  Each process prints out a \"Hello, world!\" message with a process ID. ! at least int64 is used with system_clock to ensure adequate resolution < 1 ms. !  Michael Hirsch, Ph.D. ! Compilation: ! gfortran -fcoarray=lib helloworld.f90 -lcaf_mpi ! ! or use Intel ifort: ! ifort -coarray helloworld.f90 use , intrinsic :: iso_fortran_env , only : int64 , dp => real64 implicit none integer ( int64 ) :: rate , tic = 0 , toc real ( dp ) :: telaps ! Print a message. if ( this_image () == 1 ) then call system_clock ( tic ) print * , 'number of Fortran coarray images:' , num_images () end if sync all ! semaphore, ensures message above is printed at top. print * , 'Process ' , this_image () sync all ! semaphore, ensures all have printed before toc if ( this_image () == 1 ) then call system_clock ( count = toc , count_rate = rate ) telaps = ( toc - tic ) / real ( rate , dp ) print * , 'Elapsed wall clock time' , telaps , ' seconds.' end if end program","tags":"","loc":"sourcefile/helloworld.f90.html"},{"title":"pi.f90 – Fortran 2018 examples","text":"Contents Programs coarray_pi Source Code pi.f90 Source Code program coarray_pi ! implements calculation: !  \\pi = \\int&#94;1_{-1} \\frac{dx}{\\sqrt{1-x&#94;2}} use , intrinsic :: iso_fortran_env , only : dp => real64 , int64 , stderr => error_unit implicit none integer , parameter :: wp = dp real ( wp ), parameter :: x0 = - 1.0_wp , x1 = 1.0_wp real ( wp ), parameter :: pi = 4._wp * atan ( 1.0_wp ) real ( wp ) :: psum [ * ] ! this is a scalar coarray integer ( int64 ) :: rate , tic , toc real ( wp ) :: f , x , telaps , dx integer :: i , stat , im , Ni character ( 16 ) :: cbuf psum = 0._wp if ( command_argument_count () > 0 ) then call get_command_argument ( 1 , cbuf ) read ( cbuf , * , iostat = stat ) dx if ( stat /= 0 ) error stop 'must input real number for resolution e.g. 1e-6' else dx = 1 e - 6 endif Ni = int (( x1 - x0 ) / dx ) ! (1 - (-1)) / interval im = this_image () !--------------------------------- if ( im == 1 ) then call system_clock ( tic ) print '(A,I3)' , 'number of Fortran coarray images:' , num_images () print * , 'approximating pi in ' , Ni , ' steps.' end if !--------------------------------- do i = im , Ni - 1 , num_images () ! Each image works on a subset of the problem x = x0 + i * dx f = dx / sqrt ( 1.0_wp - x ** 2 ) psum = psum + f !    print *,x,f,psum end do ! --- co_sum is much simpler, but not included even in ifort 2019 call co_sum ( psum ) !, stat=stat,errmsg=emsg) !if (stat /= 0) then !   write (stderr,*) emsg !   error stop !endif if ( im == 1 ) then print * , 'pi:' , pi , '  iterated pi: ' , psum print '(A,E10.3)' , 'pi error' , pi - psum endif if ( im == 1 ) then call system_clock ( toc ) call system_clock ( count_rate = rate ) telaps = real (( toc - tic ), wp ) / rate print '(A,E9.3,A,I3,A)' , 'Elapsed wall clock time ' , telaps , ' seconds, using' , num_images (), ' images.' end if end program","tags":"","loc":"sourcefile/pi.f90.html"},{"title":"simple_xy_wr.f90 – Fortran 2018 examples","text":"Contents Programs simple_xy_wr Source Code simple_xy_wr.f90 Source Code !     This is part of the netCDF package. !     Copyright 2006 University Corporation for Atmospheric Research/Unidata. !     See COPYRIGHT file for conditions of use. !     This is a very simple example which writes a 2D array of !     sample data. To handle this in netCDF we create two shared !     dimensions, \"x\" and \"y\", and a netCDF variable, called \"data\". !     This example demonstrates the netCDF Fortran 90 API. This is part !     of the netCDF tutorial, which can be found at: !     http://www.unidata.ucar.edu/software/netcdf/docs/netcdf-tutorial !     Full documentation of the netCDF Fortran 90 API can be found at: !     http://www.unidata.ucar.edu/software/netcdf/docs/netcdf-f90 !     $Id: simple_xy_wr.f90,v 1.7 2006/12/09 18:44:58 russ Exp $ program simple_xy_wr use netcdf implicit none ! This is the name of the data file we will create. character ( * ), parameter :: fn = \"simple_xy.nc\" ! We are writing 2D data, a 6 x 12 grid. integer , parameter :: NDIMS = 2 integer , parameter :: NX = 6 , NY = 12 ! When we create netCDF files, variables and dimensions, we get back ! an ID for each one. integer :: ncid , varid , dimids ( NDIMS ) integer :: x_dimid , y_dimid ! This is the data array we will write. It will just be filled with ! a progression of integers for this example. integer :: dout ( NY , NX ), dat ( ny , nx ) ! Loop indexes, and error handling. integer :: x , y ! Create some pretend data. If this wasn't an example program, we ! would have some real data to write, for example, model output. do concurrent ( x = 1 : NX ) do concurrent ( y = 1 : NY ) dout ( y , x ) = ( x - 1 ) * NY + ( y - 1 ) end do end do call writenc ( fn , dout ) call readnc ( fn , dat ) if (. not . all ( dat == dout )) error stop \"NetCDF IO error\" contains subroutine writenc ( fn , dout ) character ( * ), intent ( in ) :: fn integer , intent ( in ) :: dout (:,:) ! Always check the return code of every netCDF function call. In ! this example program, wrapping netCDF calls with \"call check()\" ! makes sure that any return which is not equal to nf90_noerr (0) ! will print a netCDF error message and exit. ! Create the netCDF file. The nf90_clobber parameter tells netCDF to ! overwrite this file, if it already exists. call check ( nf90_create ( fn , NF90_CLOBBER , ncid ) ) ! Define the dimensions. NetCDF will hand back an ID for each. call check ( nf90_def_dim ( ncid , \"x\" , NX , x_dimid ) ) call check ( nf90_def_dim ( ncid , \"y\" , NY , y_dimid ) ) ! The dimids array is used to pass the IDs of the dimensions of ! the variables. Note that in fortran arrays are stored in ! column-major format. dimids = ( / y_dimid , x_dimid / ) ! Define the variable. The type of the variable in this case is ! NF90_INT (4-byte integer). call check ( nf90_def_var ( ncid , \"data\" , NF90_INT , dimids , varid ) ) ! End define mode. This tells netCDF we are done defining metadata. call check ( nf90_enddef ( ncid ) ) ! Write the pretend data to the file. Although netCDF supports ! reading and writing subsets of data, in this case we write all the ! data in one operation. call check ( nf90_put_var ( ncid , varid , dout ) ) ! Close the file. This frees up any internal netCDF resources ! associated with the file, and flushes any buffers. call check ( nf90_close ( ncid ) ) end subroutine writenc subroutine readnc ( fn , dat ) character ( * ), intent ( in ) :: fn integer , intent ( out ) :: dat (:,:) ! Open the file. NF90_NOWRITE tells netCDF we want read-only access to ! the file. call check ( nf90_open ( fn , NF90_NOWRITE , ncid ) ) ! Get the varid of the data variable, based on its name. call check ( nf90_inq_varid ( ncid , \"data\" , varid ) ) ! Read the data. call check ( nf90_get_var ( ncid , varid , dat ) ) ! Check the data. if (. not . all ( dat == dout )) error stop 'r/w data mismatch' ! Close the file, freeing all resources. call check ( nf90_close ( ncid ) ) end subroutine readnc subroutine check ( status ) integer , intent ( in ) :: status if ( status /= nf90_noerr ) error stop trim ( nf90_strerror ( status )) end subroutine check end program simple_xy_wr","tags":"","loc":"sourcefile/simple_xy_wr.f90.html"},{"title":"simple_xy_rd.f90 – Fortran 2018 examples","text":"Contents Programs simple_xy_rd Source Code simple_xy_rd.f90 Source Code ! This is part of the netCDF package. ! Copyright 2006 University Corporation for Atmospheric Research/Unidata. ! See COPYRIGHT file for conditions of use. ! This is a simple example which reads a small dummy array, from a ! netCDF data file created by the companion program simple_xy_wr.f90. ! This is intended to illustrate the use of the netCDF fortran 77 ! API. This example program is part of the netCDF tutorial, which can ! be found at: ! http://www.unidata.ucar.edu/software/netcdf/docs/netcdf-tutorial ! Full documentation of the netCDF Fortran 90 API can be found at: ! http://www.unidata.ucar.edu/software/netcdf/docs/netcdf-f90 ! $Id: simple_xy_rd.f90,v 1.7 2006/12/09 18:44:58 russ Exp $ program simple_xy_rd use netcdf implicit none ! This is the name of the data file we will read. character ( * ), parameter :: fn = \"simple_xy.nc\" ! We are reading 2D data, a 6 x 12 grid. integer , parameter :: NX = 6 , NY = 12 integer :: data_in ( NY , NX ) ! This will be the netCDF ID for the file and data variable. integer :: ncid , varid ! Loop indexes, and error handling. integer :: x , y ! Open the file. NF90_NOWRITE tells netCDF we want read-only access to ! the file. call check ( nf90_open ( fn , NF90_NOWRITE , ncid ) ) ! Get the varid of the data variable, based on its name. call check ( nf90_inq_varid ( ncid , \"data\" , varid ) ) ! Read the data. call check ( nf90_get_var ( ncid , varid , data_in ) ) ! Check the data. do concurrent ( x = 1 : NX ) do concurrent ( y = 1 : NY ) if ( data_in ( y , x ) /= ( x - 1 ) * NY + ( y - 1 )) then print * , \"data_in(\" , y , \", \" , x , \") = \" , data_in ( y , x ) error stop end if end do end do ! Close the file, freeing all resources. call check ( nf90_close ( ncid ) ) print * , \"OK: reading \" , fn contains subroutine check ( status ) integer , intent ( in ) :: status if ( status /= nf90_noerr ) error stop 'error: ' // trim ( nf90_strerror ( status )) end subroutine check end program simple_xy_rd","tags":"","loc":"sourcefile/simple_xy_rd.f90.html"},{"title":"mpivers.f90 – Fortran 2018 examples","text":"Contents Programs main Source Code mpivers.f90 Source Code ! https://github.com/open-mpi/ompi/blob/master/examples/hello_usempif08.f90 program main use mpi_f08 implicit none integer :: ierr , mrank , msize , vlen character ( MPI_MAX_LIBRARY_VERSION_STRING ) :: version ! allocatable not ok call MPI_INIT ( ierr ) call MPI_COMM_RANK ( MPI_COMM_WORLD , mrank , ierr ) call MPI_COMM_SIZE ( MPI_COMM_WORLD , msize , ierr ) call MPI_GET_LIBRARY_VERSION ( version , vlen , ierr ) print '(A,I3,A,I3,A)' , 'Image ' , mrank , ' / ' , msize , ':' , version call MPI_FINALIZE ( ierr ) end","tags":"","loc":"sourcefile/mpivers.f90.html"},{"title":"helloworld.f90 – Fortran 2018 examples","text":"Contents Programs helloworld Source Code helloworld.f90 Source Code program helloworld !    Each process prints out a \"Hello, world!\" message with a process ID !  Original Author:  John Burkardt !  Modified: Michael Hirsch, Ph.D. use mpi_f08 use , intrinsic :: iso_fortran_env , only : dp => real64 implicit none integer :: i , Nproc real ( dp ) :: wtime !  Initialize MPI. call MPI_Init () !  Get the number of processes. call MPI_Comm_size ( MPI_COMM_WORLD , Nproc ) !  Get the individual process ID. call MPI_Comm_rank ( MPI_COMM_WORLD , i ) !  Print a message. if ( i == 0 ) then wtime = MPI_Wtime () print * , 'number of processes: ' , Nproc end if print * , 'Process ' , i if ( i == 0 ) then wtime = MPI_Wtime () - wtime print * , 'Elapsed wall clock time = ' , wtime , ' seconds.' end if !  Shut down MPI. call MPI_Finalize () end program","tags":"","loc":"sourcefile/helloworld.f90~2.html"},{"title":"thread_pass.f90 – Fortran 2018 examples","text":"Contents Programs main Source Code thread_pass.f90 Source Code program main ! passes data between two threads !  Author:  John Burkardt use , intrinsic :: iso_fortran_env , only : stderr => error_unit use mpi_f08 implicit none character ( 10 ) :: time integer :: mcount real :: dat ( 0 : 99 ), val ( 200 ) integer :: dest , i , num_procs , rank , tag type ( MPI_STATUS ) :: status !  Initialize MPI. call MPI_Init () !  Determine this process's rank. call MPI_Comm_rank ( MPI_COMM_WORLD , rank ) !  Find out the number of processes available. call MPI_Comm_size ( MPI_COMM_WORLD , num_procs ) if ( num_procs < 2 ) then write ( stderr , * ) 'ERROR: two threads are required, use:' write ( stderr , * ) 'mpiexec -np 2 ./mpi_pass' stop 1 endif !  Have Process 0 say hello. if ( rank == 0 ) then print * , '  An MPI test program. number of processes available ' , num_procs end if !  Process 0 expects to receive as much as 200 real values, from any source. if ( rank == 0 ) then tag = 55 call MPI_Recv ( val , size ( val ), MPI_REAL , MPI_ANY_SOURCE , tag , MPI_COMM_WORLD , status ) print * , rank , ' Got data from processor ' , status % MPI_SOURCE call MPI_Get_count ( status , MPI_REAL , mcount ) print * , rank , ' Got ' , mcount , ' elements.' print * , rank , ' val(5) = ' , val ( 5 ) !  Process 1 sends 100 real values to process 0. else if ( rank == 1 ) then print * , rank , ' - setting up data to send to process 0.' do i = 0 , 99 dat ( i ) = real ( i ) end do dest = 0 tag = 55 call MPI_Send ( dat , size ( dat ), MPI_REAL , dest , tag , MPI_COMM_WORLD ) else print * , rank , ' - MPI has no work for me!' end if call MPI_Finalize () if ( rank == 0 ) then call date_and_time ( time = time ) print * , '  Normal  execution. ' , time end if end program","tags":"","loc":"sourcefile/thread_pass.f90.html"},{"title":"bitpat.f90 – Fortran 2018 examples","text":"Contents Programs bitpat Source Code bitpat.f90 Source Code program bitpat ! shows how bit masks \"Z\" and octets \"O\" work in Fortran ! https://gcc.gnu.org/onlinedocs/gfortran/BOZ-literal-constants.html use , intrinsic :: iso_fortran_env , only : int64 , stderr => error_unit implicit none ! note that if you want other than default elements of array, you must use e.g. int( , int64) on each element ! or use a DATA statement, as per ! https://groups.google.com/forum/#!topic/comp.lang.fortran/AFtpnBh6eLg integer :: I ( 5 ) integer , parameter :: J ( 5 ) = [ 2 ** 29 , 2 ** 22 , 2 ** 15 , 2 ** 8 , 2 ** 1 ] integer ( int64 ), parameter :: hexa = int ( z '80000000' , int64 ) integer ( int64 ), parameter :: K = int ( O \"201004020100\" , int64 ) !2**34+2**27+2**20+2**13+2**6 ! while it's allowed to put BOZ at end, standard is to put BOZ at front integer , parameter :: K1 = int ( O '50147' ) ! non-standard (2003 or 2008) but virtually all compilers accept I = [ O \"4000000000\" , O \"20000000\" , O \"100000\" , O \"400\" , O \"2\" ] print '(A,5I12)' , 'exp' , j print '(A,5I12)' , 'BOZ' , i if ( any ( i /= j )) then write ( stderr , * ) 'bit pattern mismatch' stop 1 endif if ( i ( 1 ) /= 536870912 ) then write ( stderr , * ) 'bit pattern mismatch' stop 1 endif if ( j ( 1 ) /= 536870912 ) then write ( stderr , * ) 'bit pattern mismatch' stop 1 endif if ( k1 /= 20583 ) then write ( stderr , * ) 'bit pattern mismatch' stop 1 endif if ( k /= 17315143744_int64 ) then write ( stderr , * ) 'bit pattern mismatch' stop 1 endif print * , '--------------' print * , hexa end program","tags":"","loc":"sourcefile/bitpat.f90.html"},{"title":"statement_function.f90 – Fortran 2018 examples","text":"Contents Programs st Source Code statement_function.f90 Source Code program st implicit none integer :: f , i , j , k , n ! obsolete statement function (don't use) f ( n ) = n + ( i * j ) ** k i = 2 j = 3 k = 4 if (. not . f ( i - j ) == g ( i - j , i , j , k )) stop 1 contains integer function g ( n , i , j , k ) ! use this instead of statement function integer , intent ( in ) :: n , i , j , k g = n + ( i * j ) ** k end function g end program","tags":"","loc":"sourcefile/statement_function.f90.html"},{"title":"short_circuit.f90 – Fortran 2018 examples","text":"Contents Programs short_circuit_logic Source Code short_circuit.f90 Source Code program short_circuit_logic !! Fortran does [NOT have short-circuit logic](https://www.scivision.co/fortran-short-circuit-logic/), !! but some compilers enact short-circuit logic anyway. !! This can lead to confusion between different users. !! !! Compilers will definitely let you compile this, but some will segfault on run. !! NAG will raise Runtime error noting reference to not present variable. !! implicit none call msg_bad_code ( 'I did it' ) contains subroutine msg_bad_code ( txt , b ) character ( * ), intent ( in ) :: txt !! text to write if b==0 integer , intent ( in ), optional :: b !! just an input value if ( present ( b ) . and . b /= 0 ) print * , 'oops: ' // txt end subroutine msg_bad_code end program","tags":"","loc":"sourcefile/short_circuit.f90.html"},{"title":"replace_pause.f90 – Fortran 2018 examples","text":"Contents Programs replace_pause Source Code replace_pause.f90 Source Code program replace_pause ! demostrates replacement of obsolete Fortran 66 \"pause\" statement ! https://www.scivision.co/upgrade-obsolete-fortran-pause/ use , intrinsic :: iso_fortran_env , only : stdin => input_unit implicit none character ( 80 ) :: userinp !---- (1) just wait for user to press Enter, ignoring text input print * , 'Now I am waiting for you to push Enter.' read ( stdin , * ) print * , 'OK, now I am moving on to the next example.' !---- (2) wait for user to type text, that's assigned to a variable print * , 'Type something at me, then push Enter.' read ( stdin , * ) userinp print * , 'You typed: ' , userinp !---- (3) allow a system command to be executed (like very old programs used) ! this isn't implemented due to the risk of free-form text input. end program","tags":"","loc":"sourcefile/replace_pause.f90.html"},{"title":"sleep_std.f90 – Fortran 2018 examples","text":"Contents Programs stdsleep Source Code sleep_std.f90 Source Code program stdsleep ! uses unistd.h for Fortran standard compliant sleep. ! sleep() is a GNU extension, not standard Fortran. use , intrinsic :: iso_c_binding , only : c_int implicit none interface subroutine usleep ( us ) bind ( C ) import c_int integer ( c_int ), value :: us end subroutine usleep end interface integer ( c_int ), parameter :: us = 500000 print * , 'sleeping for ' , us / 1000 , ' milliseconds.' call usleep ( us ) print * , 'what a nice nap. Goodbye.' end program","tags":"","loc":"sourcefile/sleep_std.f90.html"},{"title":"pragma.f90 – Fortran 2018 examples","text":"Contents Programs procprint Source Code pragma.f90 Source Code program procprint use , intrinsic :: iso_fortran_env print * , compiler_version (), compiler_options () end program","tags":"","loc":"sourcefile/pragma.f90.html"},{"title":"f2018errorstop.f90 – Fortran 2018 examples","text":"Contents Programs f2018errorstop Source Code f2018errorstop.f90 Source Code ! checks if compiler can handle F2018 Error Stop with variable program f2018errorstop use , intrinsic :: iso_fortran_env implicit none real :: r character ( 10 ) :: c call random_number ( r ) write ( c , '(f10.3)' ) r print * , compiler_version () error stop 'dynamic error stop working: random_number: ' // c end program","tags":"","loc":"sourcefile/f2018errorstop.f90.html"},{"title":"h5mod.f90 – Fortran 2018 examples","text":"Files dependent on this one sourcefile~~h5mod.f90~~AfferentGraph sourcefile~h5mod.f90 h5mod.f90 sourcefile~hdf5simple.f90 hdf5simple.f90 sourcefile~hdf5simple.f90->sourcefile~h5mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules h5mod Source Code h5mod.f90 Source Code module h5mod ! https://support.hdfgroup.org/HDF5/doc/HL/RM_H5LT.html use , intrinsic :: iso_fortran_env , only : dp => real64 use h5lt , only : hid_t , hsize_t , & h5f_acc_trunc_f , & ! overwrite existing file h5open_f , h5fcreate_f , h5ltmake_dataset_double_f , h5fclose_f implicit none private public :: h5write contains subroutine h5write ( filename , dsname , array ) ! convenience function I made, for easy resource. ! it overwrites existing \"filename\" character ( * ), intent ( in ) :: filename , dsname real ( dp ), intent ( in ) :: array (:) integer ( hid_t ) :: fid integer :: ioerr !---------- initialize fortran interface call h5open_f ( ioerr ) if ( ioerr /= 0 ) error stop 'could not open hdf5 library' !--- create file call h5fcreate_f ( filename , h5f_acc_trunc_f , fid , ioerr ) if ( ioerr /= 0 ) error stop 'could not create file' !---------- write array to hdf5 print * , shape ( array ) call h5ltmake_dataset_double_f ( fid , dsname , rank ( array ), shape ( array , hsize_t ), array , ioerr ) if ( ioerr /= 0 ) error stop 'could not write data' !----------- close file call h5fclose_f ( fid , ioerr ) if ( ioerr /= 0 ) error stop 'could not close file' print * , 'created ' , filename end subroutine h5write end module","tags":"","loc":"sourcefile/h5mod.f90.html"},{"title":"hdf5array.f90 – Fortran 2018 examples","text":"Contents Programs h5rw Source Code hdf5array.f90 Source Code ! this example is for a typical case of read/write to an n-d array of floating point numbers program h5rw use , intrinsic :: iso_fortran_env , only : dp => real64 use hdf5 implicit none ! -------- user parameters ----------- character ( len =* ), parameter :: filename = \"simple.h5\" , dsname = \"my_image\" ! -------- initialize hdf5 ----------- integer ( hid_t ) :: fid ! file identifier integer ( hid_t ) :: dset_id ! dataset identifier integer ( hid_t ) :: dspace_id ! dataspace identifier integer ( hid_t ) :: mspace_id ! memory id integer ( hsize_t ) :: data_dims ( rank ) ! size of array ! -------- general variables ------------------ integer , parameter :: sp = selected_real_kind ( 6 , 37 ) ! single-precision float integer , parameter :: dp = selected_real_kind ( 15 , 307 ) ! double-precision float integer :: ioerr ! error flag integer :: i ! data buffers (pointers hook to these target arrays): real ( kind = dp ), target :: din ( 9 ), dout ( 9 ) type ( c_ptr ) :: f_ptr !---------------------- ! data to write (arbitrary) real ( dp ) :: array ( 9 ) array = [ 1. , 2. , 3. , 4. , 5. , 6. , 7. , 8. , 9. ] data_dims = size ( array ) din = array ! initialize fortran interface. call h5open_f ( ioerr ) if ( ioerr /= 0 ) error stop 'could not open hdf5 library' call h5fcreate_f ( filename , h5f_acc_trunc_f , fid , ioerr ) if ( ioerr /= 0 ) error stop 'could not create hdf5 file' ! create dataspaces for datasets call h5screate_simple_f ( rank , data_dims , dspace_id , ioerr ) if ( ioerr /= 0 ) error stop 'could not create data space' ! create the dataset. call h5dcreate_f ( fid , dsname , h5kind_to_type ( dp , h5_real_kind ), dspace_id , dset_id , ioerr ) if ( ioerr /= 0 ) error stop 'could not create dataset' ! write the dataset. f_ptr = c_loc ( din ( 1 )) call h5dwrite_f ( dset_id , h5kind_to_type ( dp , h5_real_kind ), f_ptr , ioerr ) if ( ioerr /= 0 ) error stop 'could not write dataset' ! close the file call h5fclose_f ( fid , ioerr ) if ( ioerr /= 0 ) error stop 'could not close file after write' ! open the file to read call h5fopen_f ( filename , h5f_acc_rdwr_f , fid , ioerr ) if ( ioerr /= 0 ) error stop 'could not open hdf5 file' ! read the dataset. ! read data back into an integer size that is larger then the original size used for writing the data f_ptr = c_loc ( dout ( 1 )) call h5dread_f ( dset_id , h5kind_to_type ( dp , h5_real_kind ), f_ptr , ioerr ) if ( ioerr /= 0 ) error stop 'could not read hdf5 dataset' print * , dout ! close the dataset. call h5dclose_f ( dset_id , ioerr ) if ( ioerr /= 0 ) error stop 'could not read hdf5 dataset after read' ! close the file. call h5fclose_f ( fid , ioerr ) if ( ioerr /= 0 ) error stop 'could not close hdf5 dataset after read' ! close fortran interface. call h5close_f ( ioerr ) if ( ioerr /= 0 ) error stop 'could not close hdf5 file after read' end program","tags":"","loc":"sourcefile/hdf5array.f90.html"},{"title":"hdf5simple.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~hdf5simple.f90~~EfferentGraph sourcefile~hdf5simple.f90 hdf5simple.f90 sourcefile~h5mod.f90 h5mod.f90 sourcefile~hdf5simple.f90->sourcefile~h5mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs hdf5simple Source Code hdf5simple.f90 Source Code ! This example is for a typical case of read/write to an n-d array of floating point numbers ! it overwrites existing \"filename\", since it is the simplest example ! https://support.hdfgroup.org/HDF5/doc/HL/RM_H5LT.html program hdf5simple use , intrinsic :: iso_fortran_env , only : dp => real64 use h5mod , only : h5write implicit none ! -------- user parameters ----------- character ( * ), parameter :: filename = \"simple.h5\" ,& ! file name dsname = \"1toN\" ! dataset name real ( dp ), allocatable :: array (:) integer :: length , ioerr character ( 8 ) :: argv ! just to keep maximum file size less than about a gigabyte (sanity check) !------------------------------------------------- call get_command_argument ( 1 , argv , status = ioerr ) if ( ioerr /= 0 ) error stop 'please input array length' read ( argv , '(I8)' ) length allocate ( array ( length )) array = fakedata ( length ) call h5write ( filename , dsname , array ) contains function fakedata ( length ) integer , intent ( in ) :: length integer :: i real ( dp ) :: fakedata ( length ) do concurrent ( i = 1 : length ) fakedata ( i ) = real ( i , dp ) end do end function fakedata end program","tags":"","loc":"sourcefile/hdf5simple.f90.html"},{"title":"hdf5demo.f90 – Fortran 2018 examples","text":"Contents Programs RWDSET_FORTRAN2003 Source Code hdf5demo.f90 Source Code ! https://support.hdfgroup.org/ftp/HDF5/examples/fortran/rwdset_fortran2003.f90 ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * !   Copyright by The HDF Group.                                               * !   Copyright by the Board of Trustees of the University of Illinois.         * !   All rights reserved.                                                      * !                                                                             * !   This file is part of HDF5.  The full HDF5 copyright notice, including     * !   terms governing use, modification, and redistribution, is contained in    * !   the files COPYING and Copyright.html.  COPYING can be found at the root   * !   of the source code distribution tree; Copyright.html can be found at the  * !   root level of an installed copy of the electronic HDF5 document set and   * !   is linked from the top-level documents page.  It can also be found at     * !   http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          * !   access to either file, you may request a copy from help@hdfgroup.org.     * ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ! ! ! The following example shows how to write and read to/from an HDF5 dataset. ! It opens the file after it creates it, obtains the dataset ! identifier, writes the data to the dataset in the file, ! then reads the dataset to memory. ! Uses updated Fortran 2003 interface with different KINDs of integers and reals. ! PROGRAM RWDSET_FORTRAN2003 USE ISO_C_BINDING USE HDF5 ! This module contains all necessary modules IMPLICIT NONE INTEGER , PARAMETER :: i1 = SELECTED_INT_KIND ( 2 ) !should map to INTEGER*1 on most modern processors INTEGER , PARAMETER :: i4 = SELECTED_INT_KIND ( 4 ) !should map to INTEGER*2 on most modern processors INTEGER , PARAMETER :: i8 = SELECTED_INT_KIND ( 9 ) !should map to INTEGER*4 on most modern processors INTEGER , PARAMETER :: i16 = SELECTED_INT_KIND ( 18 ) !should map to INTEGER*8 on most modern processors INTEGER , PARAMETER :: sp = SELECTED_REAL_KIND ( 6 , 37 ) !should map to REAL*4 on most modern processors INTEGER , PARAMETER :: dp = SELECTED_REAL_KIND ( 15 , 307 ) !should map to REAL*8 on most modern processors CHARACTER ( LEN =* ), PARAMETER :: filename = \"dsetf.h5\" ! File name CHARACTER ( LEN =* ), PARAMETER :: dsetname1 = \"dset1\" ! Dataset name CHARACTER ( LEN =* ), PARAMETER :: dsetname2 = \"dset2\" ! Dataset name CHARACTER ( LEN =* ), PARAMETER :: dsetname4 = \"dset4\" ! Dataset name CHARACTER ( LEN =* ), PARAMETER :: dsetname8 = \"dset8\" ! Dataset name CHARACTER ( LEN =* ), PARAMETER :: dsetnamer4 = \"dsetr4\" ! Dataset name CHARACTER ( LEN =* ), PARAMETER :: dsetnamer8 = \"dsetr8\" ! Dataset name INTEGER ( HID_T ) :: file_id ! File identifier INTEGER ( HID_T ) :: dset_id1 ! Dataset identifier INTEGER ( HID_T ) :: dset_id4 ! Dataset identifier INTEGER ( HID_T ) :: dset_id8 ! Dataset identifier INTEGER ( HID_T ) :: dset_id16 ! Dataset identifier INTEGER ( HID_T ) :: dset_idr4 ! Dataset identifier INTEGER ( HID_T ) :: dset_idr8 ! Dataset identifier INTEGER :: error ! Error flag INTEGER :: i ! Data buffers: INTEGER ( i1 ), DIMENSION ( 1 : 4 ), TARGET :: dset_data_i1 INTEGER ( i4 ), DIMENSION ( 1 : 4 ), TARGET :: dset_data_i4 , data_out_i4 INTEGER ( i8 ), DIMENSION ( 1 : 4 ), TARGET :: dset_data_i8 , data_out_i8 INTEGER ( i16 ), DIMENSION ( 1 : 4 ), TARGET :: dset_data_i16 , data_out_i16 INTEGER ( i8 ), DIMENSION ( 1 : 4 ), TARGET :: data_out_i8a REAL ( kind = sp ), DIMENSION ( 1 : 4 ), TARGET :: dset_data_r7 , data_out_r7 REAL ( kind = dp ), DIMENSION ( 1 : 4 ), TARGET :: dset_data_r15 , data_out_r15 INTEGER ( HSIZE_T ), DIMENSION ( 1 : 1 ) :: data_dims = ( / 4 / ) INTEGER ( HID_T ) :: dspace_id ! Dataspace identifier TYPE ( C_PTR ) :: f_ptr ! Initialize FORTRAN interface. CALL h5open_f ( error ) if ( error /= 0 ) error stop 'could not open HDF5 library' ! ! Initialize the dset_data array. ! DO i = 1 , 4 dset_data_i1 ( i ) = i dset_data_i4 ( i ) = i dset_data_i8 ( i ) = i dset_data_i16 ( i ) = i dset_data_r7 ( i ) = ( i ) * 10 0. dset_data_r15 ( i ) = ( i ) * 100 0. END DO CALL h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , error ) ! ! Create dataspaces for datasets ! CALL h5screate_simple_f ( 1 , data_dims , dspace_id , error ) ! ! Create the dataset. ! CALL H5Dcreate_f ( file_id , dsetname1 , h5kind_to_type ( i1 , H5_INTEGER_KIND ), dspace_id , dset_id1 , error ) CALL H5Dcreate_f ( file_id , dsetname2 , h5kind_to_type ( i4 , H5_INTEGER_KIND ), dspace_id , dset_id4 , error ) CALL H5Dcreate_f ( file_id , dsetname4 , h5kind_to_type ( i8 , H5_INTEGER_KIND ), dspace_id , dset_id8 , error ) CALL H5Dcreate_f ( file_id , dsetname8 , h5kind_to_type ( i16 , H5_INTEGER_KIND ), dspace_id , dset_id16 , error ) CALL H5Dcreate_f ( file_id , dsetnamer4 , h5kind_to_type ( sp , H5_REAL_KIND ), dspace_id , dset_idr4 , error ) CALL H5Dcreate_f ( file_id , dsetnamer8 , h5kind_to_type ( dp , H5_REAL_KIND ), dspace_id , dset_idr8 , error ) ! ! Write the dataset. ! f_ptr = C_LOC ( dset_data_i1 ( 1 )) CALL h5dwrite_f ( dset_id1 , h5kind_to_type ( i1 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( dset_data_i4 ( 1 )) CALL h5dwrite_f ( dset_id4 , h5kind_to_type ( i4 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( dset_data_i8 ( 1 )) CALL h5dwrite_f ( dset_id8 , h5kind_to_type ( i8 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( dset_data_i16 ( 1 )) CALL h5dwrite_f ( dset_id16 , h5kind_to_type ( i16 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( dset_data_r7 ( 1 )) CALL h5dwrite_f ( dset_idr4 , h5kind_to_type ( sp , H5_REAL_KIND ), f_ptr , error ) f_ptr = C_LOC ( dset_data_r15 ( 1 )) CALL h5dwrite_f ( dset_idr8 , h5kind_to_type ( dp , H5_REAL_KIND ), f_ptr , error ) ! ! Close the file ! CALL h5fclose_f ( file_id , error ) ! Open the file CALL h5fopen_f ( filename , H5F_ACC_RDWR_F , file_id , error ) ! ! Read the dataset. ! ! Read data back into an integer size that is larger then the original size used for ! writing the data f_ptr = C_LOC ( data_out_i8a ( 1 )) CALL h5dread_f ( dset_id1 , h5kind_to_type ( i8 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( data_out_i4 ( 1 )) CALL h5dread_f ( dset_id4 , h5kind_to_type ( i4 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( data_out_i8 ( 1 )) CALL h5dread_f ( dset_id8 , h5kind_to_type ( i8 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( data_out_i16 ( 1 )) CALL h5dread_f ( dset_id16 , h5kind_to_type ( i16 , H5_INTEGER_KIND ), f_ptr , error ) f_ptr = C_LOC ( data_out_r7 ( 1 )) CALL h5dread_f ( dset_idr4 , h5kind_to_type ( sp , H5_REAL_KIND ), f_ptr , error ) f_ptr = C_LOC ( data_out_r15 ( 1 )) CALL h5dread_f ( dset_idr8 , h5kind_to_type ( dp , H5_REAL_KIND ), f_ptr , error ) ! memory type WRITE ( * , '(A,4i8)' ) 'SELECTED_INT_KIND(2):  ' , data_out_i8a WRITE ( * , '(A,4i8)' ) 'SELECTED_INT_KIND(4):  ' , data_out_i4 WRITE ( * , '(A,4i8)' ) 'SELECTED_INT_KIND(9):  ' , data_out_i8 WRITE ( * , '(A,4i8)' ) 'SELECTED_INT_KIND(18): ' , data_out_i16 WRITE ( * , '(A,4(1x,f9.4))' ) 'SELECTED_REAL_KIND(6,37):  ' , data_out_r7 WRITE ( * , '(A,4(1x,f16.10))' ) 'SELECTED_REAL_KIND(15,307):  ' , data_out_r15 ! ! Close the dataset. ! CALL h5dclose_f ( dset_id1 , error ) CALL h5dclose_f ( dset_id4 , error ) CALL h5dclose_f ( dset_id8 , error ) CALL h5dclose_f ( dset_id16 , error ) CALL h5dclose_f ( dset_idr4 , error ) CALL h5dclose_f ( dset_idr8 , error ) ! ! Close the file. ! CALL h5fclose_f ( file_id , error ) ! ! Close FORTRAN interface. ! CALL h5close_f ( error ) END PROGRAM RWDSET_FORTRAN2003","tags":"","loc":"sourcefile/hdf5demo.f90.html"},{"title":"test.f90 – Fortran 2018 examples","text":"Contents Programs lite_test Subroutines test_dataset1D test_dataset2D test_dataset3D test_datasets test_attributes test_begin passed Source Code test.f90 Source Code ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * !   Copyright by The HDF Group.                                               * !   Copyright by the Board of Trustees of the University of Illinois.         * !   All rights reserved.                                                      * !                                                                             * !   This file is part of HDF5.  The full HDF5 copyright notice, including     * !   terms governing use, modification, and redistribution, is contained in    * !   the files COPYING and Copyright.html.  COPYING can be found at the root   * !   of the source code distribution tree; Copyright.html can be found at the  * !   root level of an installed copy of the electronic HDF5 document set and   * !   is linked from the top-level documents page.  It can also be found at     * !   http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have          * !   access to either file, you may request a copy from help@hdfgroup.org.     * ! * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ! ! ! This file contains the FORTRAN90 tests for H5LT ! program lite_test call test_dataset1D () call test_dataset2D () call test_dataset3D () call test_datasets () call test_attributes () end program lite_test !------------------------------------------------------------------------- ! test_dataset1D !------------------------------------------------------------------------- subroutine test_dataset1D () use H5LT ! module of H5LT use HDF5 ! module of HDF5 library implicit none integer , parameter :: DIM1 = 4 ; ! Dimension of array character ( len = 9 ), parameter :: filename = \"dsetf1.h5\" ! File name character ( LEN = 5 ), parameter :: dsetname1 = \"dset1\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname2 = \"dset2\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname3 = \"dset3\" ! Dataset name integer ( HID_T ) :: file_id ! File identifier integer ( HSIZE_T ), dimension ( 1 ) :: dims = ( / DIM1 / ) ! Dataset dimensions integer :: rank = 1 ! Dataset rank integer , dimension ( DIM1 ) :: buf1 ! Data buffer integer , dimension ( DIM1 ) :: bufr1 ! Data buffer real , dimension ( DIM1 ) :: buf2 ! Data buffer real , dimension ( DIM1 ) :: bufr2 ! Data buffer double precision , dimension ( DIM1 ) :: buf3 ! Data buffer double precision , dimension ( DIM1 ) :: bufr3 ! Data buffer integer :: errcode ! Error flag integer :: i ! general purpose integer call test_begin ( ' Make/Read datasets (1D)        ' ) ! ! Initialize the data array. ! do i = 1 , DIM1 buf1 ( i ) = i ; buf2 ( i ) = i ; buf3 ( i ) = i ; end do ! ! Initialize FORTRAN predefined datatypes. ! call h5open_f ( errcode ) ! ! Create a new file using default properties. ! call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , errcode ) !------------------------------------------------------------------------- ! H5T_NATIVE_INTEGER !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname1 , rank , dims , H5T_NATIVE_INTEGER , buf1 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname1 , H5T_NATIVE_INTEGER , bufr1 , dims , errcode ) ! ! compare read and write buffers. ! if (. not . all ( buf1 == bufr1 )) error stop 'read buffer differs from write buffer' !------------------------------------------------------------------------- ! H5T_NATIVE_REAL !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname2 , rank , dims , H5T_NATIVE_REAL , buf2 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname2 , H5T_NATIVE_REAL , bufr2 , dims , errcode ) ! ! compare read and write buffers. if (. not . all ( buf2 == bufr2 )) error stop 'read buffer differs from write buffer' !------------------------------------------------------------------------- ! H5T_NATIVE_DOUBLE !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname3 , rank , dims , H5T_NATIVE_DOUBLE , buf3 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname3 , H5T_NATIVE_DOUBLE , bufr3 , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf3 ( i ) . ne . bufr3 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr3 ( i ), ' and ' , buf3 ( i ) stop endif end do ! ! Close the file. ! call h5fclose_f ( file_id , errcode ) ! ! Close FORTRAN predefined datatypes. ! call h5close_f ( errcode ) call passed () ! ! end function. ! end subroutine test_dataset1D !------------------------------------------------------------------------- ! test_dataset2D !------------------------------------------------------------------------- subroutine test_dataset2D () use H5LT ! module of H5LT use HDF5 ! module of HDF5 library implicit none integer , parameter :: DIM1 = 4 ; ! columns integer , parameter :: DIM2 = 6 ; ! rows character ( len = 9 ), parameter :: filename = \"dsetf2.h5\" ! File name character ( LEN = 5 ), parameter :: dsetname1 = \"dset1\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname2 = \"dset2\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname3 = \"dset3\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname4 = \"dset4\" ! Dataset name integer ( HID_T ) :: file_id ! File identifier integer ( HSIZE_T ), dimension ( 2 ) :: dims = ( / 4 , 6 / ) ! Dataset dimensions integer :: rank = 2 ! Dataset rank integer , dimension ( DIM1 * DIM2 ) :: buf ! Data buffer integer , dimension ( DIM1 * DIM2 ) :: bufr ! Data buffer integer , dimension ( DIM1 , DIM2 ) :: buf2 ! Data buffer integer , dimension ( DIM1 , DIM2 ) :: buf2r ! Data buffer real , dimension ( DIM1 , DIM2 ) :: buf3 ! Data buffer real , dimension ( DIM1 , DIM2 ) :: buf3r ! Data buffer double precision , dimension ( DIM1 , DIM2 ) :: buf4 ! Data buffer double precision , dimension ( DIM1 , DIM2 ) :: buf4r ! Data buffer integer :: errcode ! Error flag integer :: i , j , n ! general purpose integers call test_begin ( ' Make/Read datasets (2D)        ' ) ! ! Initialize the data arrays. ! n = 1 do i = 1 , DIM1 * DIM2 buf ( i ) = n ; n = n + 1 end do do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) buf2 ( i , j ) = ( i - 1 ) * dims ( 2 ) + j ; buf3 ( i , j ) = ( i - 1 ) * dims ( 2 ) + j ; buf4 ( i , j ) = ( i - 1 ) * dims ( 2 ) + j ; end do end do ! ! Initialize FORTRAN predefined datatypes. ! call h5open_f ( errcode ) ! ! Create a new file using default properties. ! call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , errcode ) !------------------------------------------------------------------------- ! H5T_NATIVE_INT 1D buffer !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname1 , rank , dims , H5T_NATIVE_INTEGER , buf , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname1 , H5T_NATIVE_INTEGER , bufr , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 * DIM2 if ( buf ( i ) . ne . bufr ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr ( i ), ' and ' , buf ( i ) stop endif end do !------------------------------------------------------------------------- ! H5T_NATIVE_INT 2D buffer !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname2 , rank , dims , H5T_NATIVE_INTEGER , buf2 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname2 , H5T_NATIVE_INTEGER , buf2r , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) if ( buf2 ( i , j ) . ne . buf2r ( i , j ) ) then print * , 'read buffer differs from write buffer' print * , buf2r ( i , j ), ' and ' , buf2 ( i , j ) stop endif end do end do !------------------------------------------------------------------------- ! H5T_NATIVE_REAL !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname3 , rank , dims , H5T_NATIVE_REAL , buf3 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname3 , H5T_NATIVE_REAL , buf3r , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) if ( buf3 ( i , j ) . ne . buf3r ( i , j ) ) then print * , 'read buffer differs from write buffer' print * , buf3r ( i , j ), ' and ' , buf3 ( i , j ) stop endif end do end do !------------------------------------------------------------------------- ! H5T_NATIVE_DOUBLE !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname4 , rank , dims , H5T_NATIVE_DOUBLE , buf4 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname4 , H5T_NATIVE_DOUBLE , buf4r , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) if ( buf4 ( i , j ) . ne . buf4r ( i , j ) ) then print * , 'read buffer differs from write buffer' print * , buf4r ( i , j ), ' and ' , buf4 ( i , j ) stop endif end do end do ! ! Close the file. ! call h5fclose_f ( file_id , errcode ) ! ! Close FORTRAN predefined datatypes. ! call h5close_f ( errcode ) call passed () ! ! end function. ! end subroutine test_dataset2D !------------------------------------------------------------------------- ! test_dataset3D !------------------------------------------------------------------------- subroutine test_dataset3D () use H5LT ! module of H5LT use HDF5 ! module of HDF5 library implicit none integer , parameter :: DIM1 = 6 ; ! columns integer , parameter :: DIM2 = 4 ; ! rows integer , parameter :: DIM3 = 2 ; ! layers character ( len = 9 ), parameter :: filename = \"dsetf3.h5\" ! File name character ( LEN = 5 ), parameter :: dsetname1 = \"dset1\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname2 = \"dset2\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname3 = \"dset3\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname4 = \"dset4\" ! Dataset name integer ( HID_T ) :: file_id ! File identifier integer ( HSIZE_T ), dimension ( 3 ) :: dims = ( / DIM1 , DIM2 , DIM3 / ) ! Dataset dimensions integer ( HSIZE_T ), dimension ( 3 ) :: dimsr ! Dataset dimensions integer , dimension ( DIM1 * DIM2 * DIM3 ) :: buf ! Data buffer integer , dimension ( DIM1 * DIM2 * DIM3 ) :: bufr ! Data buffer integer , dimension ( DIM1 , DIM2 , DIM3 ) :: buf2 ! Data buffer integer , dimension ( DIM1 , DIM2 , DIM3 ) :: buf2r ! Data buffer real , dimension ( DIM1 , DIM2 , DIM3 ) :: buf3 ! Data buffer real , dimension ( DIM1 , DIM2 , DIM3 ) :: buf3r ! Data buffer double precision , dimension ( DIM1 , DIM2 , DIM3 ) :: buf4 ! Data buffer double precision , dimension ( DIM1 , DIM2 , DIM3 ) :: buf4r ! Data buffer integer :: rank = 3 ! Dataset rank integer :: errcode ! Error flag integer :: i , j , k , n ! general purpose integers integer :: type_class integer ( SIZE_T ) :: type_size call test_begin ( ' Make/Read datasets (3D)        ' ) ! ! Initialize the data array. ! n = 1 do i = 1 , DIM1 * DIM2 * DIM3 buf ( i ) = n ; n = n + 1 end do n = 1 do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) do k = 1 , dims ( 3 ) buf2 ( i , j , k ) = n ; buf3 ( i , j , k ) = n ; buf4 ( i , j , k ) = n ; n = n + 1 end do end do end do ! ! Initialize FORTRAN predefined datatypes. ! call h5open_f ( errcode ) ! ! Create a new file using default properties. ! call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , errcode ) !------------------------------------------------------------------------- ! H5T_NATIVE_INT 1D buffer !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname1 , rank , dims , H5T_NATIVE_INTEGER , buf , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname1 , H5T_NATIVE_INTEGER , bufr , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 * DIM2 * DIM3 if ( buf ( i ) . ne . bufr ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr ( i ), ' and ' , buf ( i ) stop endif end do !------------------------------------------------------------------------- ! H5T_NATIVE_INT 3D buffer !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname2 , rank , dims , H5T_NATIVE_INTEGER , buf2 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname2 , H5T_NATIVE_INTEGER , buf2r , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) do k = 1 , dims ( 3 ) if ( buf2 ( i , j , k ) . ne . buf2r ( i , j , k ) ) then print * , 'read buffer differs from write buffer' print * , buf2r ( i , j , k ), ' and ' , buf2 ( i , j , k ) stop endif end do end do end do !------------------------------------------------------------------------- ! H5T_NATIVE_REAL !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname3 , rank , dims , H5T_NATIVE_REAL , buf3 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname3 , H5T_NATIVE_REAL , buf3r , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) do k = 1 , dims ( 3 ) if ( buf3 ( i , j , k ) . ne . buf3r ( i , j , k ) ) then print * , 'read buffer differs from write buffer' print * , buf3r ( i , j , k ), ' and ' , buf3 ( i , j , k ) stop endif end do end do end do !------------------------------------------------------------------------- ! H5T_NATIVE_DOUBLE !------------------------------------------------------------------------- ! ! write dataset. ! call h5ltmake_dataset_f ( file_id , dsetname4 , rank , dims , H5T_NATIVE_DOUBLE , buf4 , errcode ) ! ! read dataset. ! call h5ltread_dataset_f ( file_id , dsetname4 , H5T_NATIVE_DOUBLE , buf4r , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , dims ( 1 ) do j = 1 , dims ( 2 ) do k = 1 , dims ( 3 ) if ( buf4 ( i , j , k ) . ne . buf4r ( i , j , k ) ) then print * , 'read buffer differs from write buffer' print * , buf4r ( i , j , k ), ' and ' , buf4 ( i , j , k ) stop endif end do end do end do call h5ltget_dataset_info_f ( file_id , dsetname4 , dimsr , type_class , type_size , errcode ) ! ! compare dimensions ! do i = 1 , rank if ( dimsr ( i ) . ne . dims ( i ) ) then print * , 'dimensions differ ' stop endif end do ! ! Close the file. ! call h5fclose_f ( file_id , errcode ) ! ! Close FORTRAN predefined datatypes. ! call h5close_f ( errcode ) call passed () ! ! end function. ! end subroutine test_dataset3D !------------------------------------------------------------------------- ! test_datasets !------------------------------------------------------------------------- subroutine test_datasets () use H5LT ! module of H5LT use HDF5 ! module of HDF5 library implicit none character ( len = 9 ), parameter :: filename = \"dsetf4.h5\" ! File name integer ( HID_T ) :: file_id ! File identifier integer :: errcode ! Error flag integer , parameter :: DIM1 = 10 ; ! Dimension of array character ( LEN = 5 ), parameter :: dsetname1 = \"dset1\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname2 = \"dset2\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname3 = \"dset3\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname4 = \"dset4\" ! Dataset name character ( LEN = 5 ), parameter :: dsetname5 = \"dset5\" ! Dataset name integer ( HSIZE_T ), dimension ( 1 ) :: dims = ( / DIM1 / ) ! Dataset dimensions integer ( HSIZE_T ), dimension ( 1 ) :: dimsr ! Dataset dimensions integer :: rank = 1 ! Dataset rank integer :: rankr ! Dataset rank character ( LEN = 8 ), parameter :: buf1 = \"mystring\" ! Data buffer character ( LEN = 8 ) :: buf1r ! Data buffer integer , dimension ( DIM1 ) :: buf2 ! Data buffer integer , dimension ( DIM1 ) :: bufr2 ! Data buffer real , dimension ( DIM1 ) :: buf3 ! Data buffer real , dimension ( DIM1 ) :: bufr3 ! Data buffer double precision , dimension ( DIM1 ) :: buf4 ! Data buffer double precision , dimension ( DIM1 ) :: bufr4 ! Data buffer integer :: i , n ! general purpose integer integer :: has ! general purpose integer integer :: type_class integer ( SIZE_T ) :: type_size ! ! Initialize FORTRAN predefined datatypes. ! call h5open_f ( errcode ) ! ! Create a new file using default properties. ! call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , errcode ) ! ! Initialize the data array. ! n = 1 do i = 1 , DIM1 buf2 ( i ) = n ; buf3 ( i ) = n ; buf4 ( i ) = n ; n = n + 1 ; end do !------------------------------------------------------------------------- ! int !------------------------------------------------------------------------- call test_begin ( ' Make/Read datasets (integer)   ' ) ! ! write dataset. ! call h5ltmake_dataset_int_f ( file_id , dsetname2 , rank , dims , buf2 , errcode ) ! ! read dataset. ! call h5ltread_dataset_int_f ( file_id , dsetname2 , bufr2 , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf2 ( i ) . ne . bufr2 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr2 ( i ), ' and ' , buf2 ( i ) stop endif end do call passed () !------------------------------------------------------------------------- ! real !------------------------------------------------------------------------- call test_begin ( ' Make/Read datasets (float)     ' ) ! ! write dataset. ! call h5ltmake_dataset_float_f ( file_id , dsetname3 , rank , dims , buf3 , errcode ) ! ! read dataset. ! call h5ltread_dataset_float_f ( file_id , dsetname3 , bufr3 , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf3 ( i ) . ne . bufr3 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr3 ( i ), ' and ' , buf3 ( i ) stop endif end do call passed () !------------------------------------------------------------------------- ! double !------------------------------------------------------------------------- call test_begin ( ' Make/Read datasets (double)    ' ) ! ! write dataset. ! call h5ltmake_dataset_double_f ( file_id , dsetname4 , rank , dims , buf4 , errcode ) ! ! read dataset. ! call h5ltread_dataset_double_f ( file_id , dsetname4 , bufr4 , dims , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf4 ( i ) . ne . bufr4 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr4 ( i ), ' and ' , buf4 ( i ) stop endif end do call passed () !------------------------------------------------------------------------- ! string !------------------------------------------------------------------------- call test_begin ( ' Make/Read datasets (string)    ' ) ! ! write dataset. ! call h5ltmake_dataset_string_f ( file_id , dsetname5 , buf1 , errcode ) ! ! read dataset. ! call h5ltread_dataset_string_f ( file_id , dsetname5 , buf1r , errcode ) ! ! compare read and write buffers. ! if ( buf1 . ne . buf1r ) then print * , 'read buffer differs from write buffer' print * , buf1 , ' and ' , buf1r stop endif call passed () call test_begin ( ' Get dataset dimensions/info    ' ) !------------------------------------------------------------------------- ! h5ltget_dataset_ndims_f !------------------------------------------------------------------------- call h5ltget_dataset_ndims_f ( file_id , dsetname4 , rankr , errcode ) if ( rankr . ne . rank ) then print * , 'h5ltget_dataset_ndims_f return error' stop endif !------------------------------------------------------------------------- ! test h5ltfind_dataset_f function !------------------------------------------------------------------------- has = h5ltfind_dataset_f ( file_id , dsetname4 ) if ( has . ne . 1 ) then print * , 'h5ltfind_dataset_f return error' stop endif !------------------------------------------------------------------------- ! test h5ltget_dataset_info_f function !------------------------------------------------------------------------- call h5ltget_dataset_info_f ( file_id , dsetname4 , dimsr , type_class , type_size , errcode ) ! ! compare dimensions ! do i = 1 , rank if ( dimsr ( i ) . ne . dims ( i ) ) then print * , 'dimensions differ ' stop endif end do if ( type_class . ne . 1 ) then ! H5T_FLOAT print * , 'wrong type class ' stop endif ! ! Close the file. ! call h5fclose_f ( file_id , errcode ) ! ! Close FORTRAN predefined datatypes. ! call h5close_f ( errcode ) call passed () ! ! end function. ! end subroutine test_datasets !------------------------------------------------------------------------- ! test_attributes !------------------------------------------------------------------------- subroutine test_attributes () use H5LT ! module of H5LT use HDF5 ! module of HDF5 library implicit none character ( len = 9 ), parameter :: filename = \"dsetf5.h5\" ! File name integer ( HID_T ) :: file_id ! File identifier integer , parameter :: DIM1 = 10 ; ! Dimension of array character ( LEN = 5 ), parameter :: attrname1 = \"attr1\" ! Attribute name character ( LEN = 5 ), parameter :: attrname2 = \"attr2\" ! Attribute name character ( LEN = 5 ), parameter :: attrname3 = \"attr3\" ! Attribute name character ( LEN = 5 ), parameter :: attrname4 = \"attr4\" ! Attribute name character ( LEN = 5 ), parameter :: attrname5 = \"attr5\" ! Attribute name character ( LEN = 8 ), parameter :: buf1 = \"mystring\" ! Data buffer character ( LEN = 8 ) :: bufr1 ! Data buffer integer , dimension ( DIM1 ) :: buf2 ! Data buffer integer , dimension ( DIM1 ) :: bufr2 ! Data buffer real , dimension ( DIM1 ) :: buf3 ! Data buffer real , dimension ( DIM1 ) :: bufr3 ! Data buffer double precision , dimension ( DIM1 ) :: buf4 ! Data buffer double precision , dimension ( DIM1 ) :: bufr4 ! Data buffer integer :: errcode ! Error flag integer :: i , n ! general purpose integer integer ( SIZE_T ) size ! size of attribute array integer :: rankr ! rank integer ( HSIZE_T ), dimension ( 1 ) :: dimsr ! attribute dimensions integer :: type_class integer ( SIZE_T ) :: type_size integer ( HSIZE_T ), dimension ( 1 ) :: dims = ( / DIM1 / ) ! Dataset dimensions integer :: rank = 1 ! Dataset rank character ( LEN = 5 ), parameter :: dsetname1 = \"dset1\" ! Dataset name integer , dimension ( DIM1 ) :: buf ! Data buffer ! ! Initialize FORTRAN predefined datatypes. ! call h5open_f ( errcode ) ! ! Create a new file using default properties. ! call h5fcreate_f ( filename , H5F_ACC_TRUNC_F , file_id , errcode ) ! ! make a dataset. ! call h5ltmake_dataset_int_f ( file_id , dsetname1 , rank , dims , buf , errcode ) ! ! Initialize the data array. ! size = DIM1 n = 1 do i = 1 , DIM1 buf2 ( i ) = n ; buf3 ( i ) = n ; buf4 ( i ) = n ; n = n + 1 ; end do !------------------------------------------------------------------------- ! int !------------------------------------------------------------------------- call test_begin ( ' Set/Get attributes int         ' ) ! ! write attribute. ! call h5ltset_attribute_int_f ( file_id , dsetname1 , attrname2 , buf2 , size , errcode ) ! ! read attribute. ! call h5ltget_attribute_int_f ( file_id , dsetname1 , attrname2 , bufr2 , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf2 ( i ) . ne . bufr2 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr2 ( i ), ' and ' , buf2 ( i ) stop endif end do call passed () !------------------------------------------------------------------------- ! float !------------------------------------------------------------------------- call test_begin ( ' Set/Get attributes float       ' ) ! ! write attribute. ! call h5ltset_attribute_float_f ( file_id , dsetname1 , attrname3 , buf3 , size , errcode ) ! ! read attribute. ! call h5ltget_attribute_float_f ( file_id , dsetname1 , attrname3 , bufr3 , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf3 ( i ) . ne . bufr3 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr3 ( i ), ' and ' , buf3 ( i ) stop endif end do call passed () !------------------------------------------------------------------------- ! double !------------------------------------------------------------------------- call test_begin ( ' Set/Get attributes double      ' ) ! ! write attribute. ! call h5ltset_attribute_double_f ( file_id , dsetname1 , attrname4 , buf4 , size , errcode ) ! ! read attribute. ! call h5ltget_attribute_double_f ( file_id , dsetname1 , attrname4 , bufr4 , errcode ) ! ! compare read and write buffers. ! do i = 1 , DIM1 if ( buf4 ( i ) . ne . bufr4 ( i ) ) then print * , 'read buffer differs from write buffer' print * , bufr4 ( i ), ' and ' , buf4 ( i ) stop endif end do call passed () !------------------------------------------------------------------------- ! string !------------------------------------------------------------------------- call test_begin ( ' Set/Get attributes string      ' ) ! ! write attribute. ! call h5ltset_attribute_string_f ( file_id , dsetname1 , attrname5 , buf1 , errcode ) ! ! read attribute. ! call h5ltget_attribute_string_f ( file_id , dsetname1 , attrname5 , bufr1 , errcode ) ! ! compare read and write buffers. ! if ( buf1 . ne . bufr1 ) then print * , 'read buffer differs from write buffer' print * , buf1 , ' and ' , bufr1 stop endif call passed () !------------------------------------------------------------------------- ! get attribute rank !------------------------------------------------------------------------- call test_begin ( ' Get attribute rank/info        ' ) call h5ltget_attribute_ndims_f ( file_id , dsetname1 , attrname2 , rankr , errcode ) if ( rankr . ne . 1 ) then print * , 'h5ltget_attribute_ndims_f return error' stop endif call h5ltget_attribute_info_f ( file_id , dsetname1 , attrname2 , dimsr , type_class , type_size , errcode ) ! ! compare dimensions ! do i = 1 , rank if ( dimsr ( i ) . ne . dims ( i ) ) then print * , 'dimensions differ ' stop endif end do ! ! Close the file. ! call h5fclose_f ( file_id , errcode ) ! ! Close FORTRAN predefined datatypes. ! call h5close_f ( errcode ) call passed () ! ! end function. ! end subroutine test_attributes !------------------------------------------------------------------------- ! test_begin !------------------------------------------------------------------------- subroutine test_begin ( string ) character ( LEN =* ), intent ( IN ) :: string write ( * , fmt = '(14a)' , advance = 'no' ) string write ( * , fmt = '(40x,a)' , advance = 'no' ) ' ' end subroutine test_begin !------------------------------------------------------------------------- ! passed !------------------------------------------------------------------------- subroutine passed () write ( * , fmt = '(6a)' ) 'PASSED' end subroutine passed","tags":"","loc":"sourcefile/test.f90.html"},{"title":"cmake_hdf5_test.f90 – Fortran 2018 examples","text":"Contents Programs hdf5_hello Source Code cmake_hdf5_test.f90 Source Code program hdf5_hello use hdf5 use h5lt use h5ds integer error call h5open_f ( error ) call h5close_f ( error ) end","tags":"","loc":"sourcefile/cmake_hdf5_test.f90.html"},{"title":"print_vs_write.f90 – Fortran 2018 examples","text":"Contents Programs print_vs_write Source Code print_vs_write.f90 Source Code ! Fortran 2003 standard states that !  print *, !  write (*,*) ! are equivalent. Let's show this via looking at disassembler code across compilers. ! Let's also see what happens with \"flush\" ! ! Result: assembly output is identical with 3 types of print statements. ! program print_vs_write use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none print * , '☀ ☁ ☂ ☃ ☄' !write(stdout, *) '☀ ☁ ☂ ☃ ☄' !write(*,'(A)') '☀ ☁ ☂ ☃ ☄' flush ( stdout ) ! this obviously generates distinct assembly ! write(stdout, '(A)', advance='no') '☀ ☁ ☂ ☃ ☄' end program","tags":"","loc":"sourcefile/print_vs_write.f90.html"},{"title":"overwrite_stdout.f90 – Fortran 2018 examples","text":"Contents Programs overwrite_stdout Source Code overwrite_stdout.f90 Source Code program overwrite_stdout ! overwrites terminal stdout in place e.g. for update status ! char(13) is carriage return use , intrinsic :: iso_c_binding , only : c_int use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none ! interface is just to be purely Fortran 2018 compilant, since sleep() is not standard. You don't strictly need it. interface subroutine usleep ( us ) bind ( c ) import c_int integer ( c_int ), value :: us end subroutine usleep end interface integer :: i integer , parameter :: N = 5 do i = 1 , N write ( stdout , '(A1,F7.3,A1)' , advance = 'no' ) achar ( 13 ), i / real ( N ) * 100 , '%' flush ( stdout ) ! Fortran 2003, necessary for ifort call usleep ( 200000_c_int ) enddo end program","tags":"","loc":"sourcefile/overwrite_stdout.f90.html"},{"title":"ascii.f90 – Fortran 2018 examples","text":"Contents Programs ascii Source Code ascii.f90 Source Code program ascii print * , 'next is a form feed' , achar ( 12 ) print * , 'that was a form feed' print * , 'this is BEL' , achar ( 7 ) end program","tags":"","loc":"sourcefile/ascii.f90.html"},{"title":"charlen.f90 – Fortran 2018 examples","text":"Contents Programs charlen Source Code charlen.f90 Source Code program charlen ! shows how to properly specify character length and character array character * ( 5 ) :: cb5 ! obsolete, don't use character ( 5 ) :: c5 ! good to use character ( * ), parameter :: ca ( 2 ) = 'hello' if (. not . all ([ len ( cb5 ) == 5 , len ( c5 ) == 5 , len ( ca ) == 5 , size ( ca ) == 2 ])) stop 1 print * , ca end program","tags":"","loc":"sourcefile/charlen.f90.html"},{"title":"str2int.f90 – Fortran 2018 examples","text":"Contents Programs str2int Source Code str2int.f90 Source Code program str2int use , intrinsic :: iso_fortran_env , only : stdin => input_unit implicit none integer :: M read ( stdin , * ) M print * , M end program","tags":"","loc":"sourcefile/str2int.f90.html"},{"title":"special_characters.f90 – Fortran 2018 examples","text":"Contents Programs special_char Source Code special_characters.f90 Source Code program special_char ! This program shows a few special ASCII characters in Fortran. ! https://en.wikipedia.org/wiki/ASCII#Character_groups character , parameter :: & nul = char ( 0 ), & etx = char ( 3 ), & tab = char ( 9 ), & backslash = char ( 92 ) ! necessary for strict compilers like PGI and Flang in strings print * , 'null' print '(A1)' , nul print * , 'etx' print '(A1)' , etx print * , 'tab' print '(A1)' , tab print * , 'backslash' print '(A1)' , backslash end program","tags":"","loc":"sourcefile/special_characters.f90.html"},{"title":"split_string.f90 – Fortran 2018 examples","text":"Contents Programs splitstring Source Code split_string.f90 Source Code ! split a string about a delimiter token, return part before delim ! ! with regard to length of CHARACTER, it's probably best to pick a length longer than you'll need ! and trim rather than using assumed size, particularly if interfacing with other languages ! CHARACTER assumed size seems to work, but is not reliable in diverse enviroments. ! Your time is more valueable than a few bytes of RAM. program splitstring use , intrinsic :: iso_fortran_env , stdin => input_unit character ( * ), parameter :: mystr = \"hello.txt\" character (:), allocatable :: stem stem = split ( mystr , '.' ) print * , stem contains pure function split ( instr , delm ) character ( * ), intent ( in ) :: instr character ( 1 ), intent ( in ) :: delm character (:), allocatable :: split integer :: idx idx = scan ( instr , delm ) split = instr ( 1 : idx - 1 ) end function split end program !---------------------------------------","tags":"","loc":"sourcefile/split_string.f90.html"},{"title":"devnull_simple.f90 – Fortran 2018 examples","text":"Contents Programs nulltest Source Code devnull_simple.f90 Source Code program nulltest use , intrinsic :: iso_fortran_env , only : int64 implicit none integer ( int64 ) :: tic , toc , rate character ( * ), parameter :: nulunix = '/dev/null' , nulwin = 'NUL' , fout = 'out.txt' integer , parameter :: N = 1000 integer :: ios , u , i real :: tnul , tscr ! --- benchmark NUL call system_clock ( tic , count_rate = rate ) open ( newunit = u , file = nulunix , status = 'replace' , iostat = ios , action = 'write' ) if ( ios /= 0 ) open ( newunit = u , file = nulwin , status = 'replace' , iostat = ios , action = 'write' ) if ( ios /= 0 ) error stop 'could not open a NULL file handle' do i = 1 , N write ( u , * ) 'blah blah blah' flush ( u ) enddo close ( u ) call system_clock ( toc ) tnul = ( toc - tic ) / real ( rate ) print * , tnul , ' seconds to write to NUL' !---- benchmark scratch call system_clock ( tic ) open ( newunit = u , status = 'scratch' ) do i = 1 , N write ( u , * ) 'blah blah blah' flush ( u ) enddo close ( u ) call system_clock ( toc ) tscr = ( toc - tic ) / real ( rate ) print * , tscr , ' seconds to write to scratch file' print '(A,F7.3,A)' , 'NUL is ' , tscr / tnul , ' times faster than scratch.' end program","tags":"","loc":"sourcefile/devnull_simple.f90.html"},{"title":"terminal_io.f90 – Fortran 2018 examples","text":"Contents Programs terminal_io Source Code terminal_io.f90 Source Code program terminal_io use , intrinsic :: iso_fortran_env implicit none character ( 80 ) :: txt write ( output_unit , '(A,I1)' ) 'This is stdout, unit # ' , output_unit write ( error_unit , '(A,I1,A,I1)' ) 'This is stderr, unit # ' , error_unit , ' type anything you want to input_unit # ' , input_unit read ( input_unit , * ) txt print * , 'you typed ' , txt end program","tags":"","loc":"sourcefile/terminal_io.f90.html"},{"title":"devnull.f90 – Fortran 2018 examples","text":"Contents Programs nulltest Source Code devnull.f90 Source Code program nulltest use , intrinsic :: iso_fortran_env , only : int64 , wp => real32 implicit none ! Benchmarks platform independent null file writing behavior ! NUL or NUL: works on Windows 10 ! /dev/null is used for Mac, Linux, BSD, Unix, WSL, Cygwin... ! ! Flush() is used to avoid merely buffering the data, giving artificial results. ! in a real program, the amount of data written to disk is substantial ! on each iteration, and the buffer would naturally get flushed. ! Yes, the benchmark is more aggressive than normal use--that's why ! filesystem buffering is used by Fortran and programs in general. ! ! The point of this program is to show that by inserting '/dev/null' ! as the filename for file outputs you never use, big speedups can result ! from modifying a single parameter (the file name). ! This saves you from commenting out lines, using IF statements and possibly ! making mistakes in doing so. ! ! character ( * ), parameter :: nulunix = '/dev/null' , nulwin = 'NUL' , fout = 'out.txt' integer , parameter :: Nrun = 1000 integer :: ios , u real ( wp ) :: tnul , tscratch , tfile !---  BENCHMARK NUL ----------- ! status='old' is used as a failsafe, to avoid creating an actual file ! in case of mistake. It is not necessary to specify status='old'. open ( newunit = u , file = nulunix , status = 'old' , iostat = ios , action = 'write' ) if ( ios /= 0 ) open ( newunit = u , file = nulwin , status = 'old' , iostat = ios , action = 'write' ) if ( ios /= 0 ) error stop 'could not open a NULL file handle' tnul = writetime ( u , Nrun ) print '(A10,F10.3,A)' , 'nul: ' , tnul , ' ms' !---- BENCHMARK SCRATCH -------------- open ( newunit = u , status = 'scratch' ) tscratch = writetime ( u , Nrun ) print '(A10,F10.3,A)' , 'scratch: ' , tscratch , ' ms' !---- BENCHMARK FILE -------- ! note that open() default position=asis, access=sequential open ( newunit = u , status = 'replace' , file = fout ) tfile = writetime ( u , Nrun ) print '(A10,F10.3,A)' , 'file: ' , tfile , ' ms' contains real ( wp ) function writetime ( u , Nrun ) integer , intent ( in ) :: u , Nrun integer ( int64 ) :: tic , toc , tmin , rate integer , volatile :: i integer j tmin = huge ( 0_int64 ) ! need to avoid SAVE behavior by not assigning at initialization call system_clock ( count_rate = rate ) do j = 1 , 3 call system_clock ( tic ) do i = 1 , Nrun write ( u , * ) 'into nothingness I go....' , i flush ( u ) enddo call system_clock ( toc ) if ( toc - tic < tmin ) tmin = toc - tic enddo writetime = tmin / rate close ( u ) end function writetime end program","tags":"","loc":"sourcefile/devnull.f90.html"},{"title":"file_or_console_output.f90 – Fortran 2018 examples","text":"Contents Programs file_or_console Source Code file_or_console_output.f90 Source Code program file_or_console use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none character (:), allocatable :: filename character ( 256 ) :: buf integer :: i , u call get_command_argument ( 1 , buf , status = i ) if ( i == 0 ) then filename = trim ( buf ) ! Fortran 2003 auto-allocate print * , 'writing to ' , filename open ( newunit = u , file = filename , form = 'formatted' ) else u = stdout endif i = 3 ! test data write ( u , * ) i , i ** 2 , i ** 3 if ( u /= stdout ) close ( u ) ! closing stdout can disable text console output print * , 'goodbye' ! end program implies closing all file units, but here we close in case you'd use in subprogram (procedure), where the file reference would persist. end program","tags":"","loc":"sourcefile/file_or_console_output.f90.html"},{"title":"expanduser.f90 – Fortran 2018 examples","text":"Contents Programs home Modules fsutils Source Code expanduser.f90 Source Code module fsutils implicit none contains function expanduser ( indir ) character (:), allocatable :: expanduser character ( * ), intent ( in ) :: indir ! -- resolve home directory as Fortran does not understand tilde ! works for Linux, Mac, Windows and more if ( len_trim ( indir ) < 1 ) then stop 'must provide path to expand' elseif ( indir ( 1 : 1 ) /= '~' ) then expanduser = trim ( adjustl ( indir )) return elseif ( len_trim ( indir ) < 3 ) then expanduser = homedir () else expanduser = homedir () // trim ( adjustl ( indir ( 3 :))) endif end function expanduser function homedir () character (:), allocatable :: homedir character :: filesep character ( 256 ) :: buf ! assume MacOS/Linux/BSD/Cygwin/WSL filesep = '/' call get_environment_variable ( \"HOME\" , buf ) if ( len_trim ( buf ) == 0 ) then ! Windows call get_environment_variable ( \"USERPROFILE\" , buf ) filesep = char ( 92 ) endif homedir = trim ( buf ) // filesep end function homedir end module fsutils !------ demo program home use fsutils implicit none ! explores what '~' means for paths in Fortran ! Note: when testing, enclose argument in '~/test.txt' quotes or !  shell will expand '~' before it gets to Fortran! character (:), allocatable :: expanded character ( 256 ) :: buf call get_command_argument ( 1 , buf ) expanded = expanduser ( trim ( buf )) print '(A)' , trim ( buf ) print '(A)' , expanded end program","tags":"","loc":"sourcefile/expanduser.f90.html"},{"title":"fileopen-readonly.f90 – Fortran 2018 examples","text":"Contents Programs openreadonly Source Code fileopen-readonly.f90 Source Code program openreadonly ! NOTE: chmod is non-standard, and will crash ifort runtime. use , intrinsic :: iso_fortran_env , only : stderr => error_unit implicit none character ( * ), parameter :: fnro = 'ro.txt' !--- show read only file by filesystem is not safe from deletion ---- call createro ( fnro ) call deletefile ( fnro ) ! this is MY unlink, since the GNU extension is non-standard and crashes ifort runtimes. print * , 'deleted read-only: ' , fnro contains subroutine createro ( fn ) ! creates readonly file character ( * ), intent ( in ) :: fn character ( * ), parameter :: txt = 'i am read only' integer u , ios open ( newunit = u , file = fn , form = 'formatted' , status = 'unknown' , iostat = ios , action = 'write' ) if ( ios /= 0 ) error stop 'could not create readonly file' write ( u , iostat = ios , fmt =* ) txt if ( ios /= 0 ) error stop 'could not write file' close ( u ) print * , 'created read-only: ' , fn end subroutine subroutine deletefile ( fn ) character ( * ), intent ( in ) :: fn integer :: u , ios logical :: fexist ! Fortran-standard way to delete a file. open ( newunit = u , file = fn , status = 'old' ) close ( u , status = 'delete' , iostat = ios ) if ( ios /= 0 ) then write ( stderr , * ) 'failed to delete' , fn , ios error stop endif inquire ( file = fn , exist = fexist ) if ( fexist ) then write ( stderr , * ) 'failed to delete' , fn error stop endif end subroutine deletefile end program","tags":"","loc":"sourcefile/fileopen-readonly.f90.html"},{"title":"noenv.f90 – Fortran 2018 examples","text":"Contents Programs noenv Source Code noenv.f90 Source Code program noenv use , intrinsic :: iso_fortran_env , only : error_unit implicit none character ( 4 ) :: buf integer :: h , ios call get_environment_variable ( 'LINES' , buf , status = ios ) if ( ios /= 0 ) then write ( error_unit , * ) 'got error code' , ios , 'on trying to get LINES' stop endif read ( buf , * ) h end program","tags":"","loc":"sourcefile/noenv.f90.html"},{"title":"nans.F90 – Fortran 2018 examples","text":"Contents Programs test_nan Source Code nans.F90 Source Code program test_nan ! Note that -Ofast and -ffast-math break this program-- ! NaN are not IEEE compiliant if using -Ofast or -ffast-math. ! ! Gfortran >= 6 needed for ieee_arithmetic: ieee_is_nan !use, intrinsic :: iso_c_binding, only: sp=>C_FLOAT, dp=>C_DOUBLE, qp=>C_LONG_DOUBLE ! more precision for real128,complex256 by using iso_fortran_env vs.  iso_c_binding use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 , qp => real128 use , intrinsic :: iso_fortran_env , only : int32 , int64 use , intrinsic :: ieee_arithmetic , only : ieee_value , ieee_quiet_nan , ieee_is_nan implicit none real ( sp ) :: nan_sp , nan_bit real ( dp ) :: nan_dp #if REAL128 real ( qp ) :: nan_qp complex ( dp ) :: nan_zp complex ( qp ) :: nan_zqp #endif integer ( int32 ) :: ISP integer ( int64 ) :: IDP ! this is the cross platform way to get NaN on modern compilers including gfortran and ifort. nan_sp = ieee_value ( 1. , ieee_quiet_nan ) nan_dp = ieee_value ( 1. , ieee_quiet_nan ) #if REAL128 nan_qp = ieee_value ( 1. , ieee_quiet_nan ) nan_zp = ieee_value ( 1. , ieee_quiet_nan ) nan_zqp = ieee_value ( 1. , ieee_quiet_nan ) #endif ! this is a bit-pattern way to get NaN by IEEE754 definition #if IEEENAN nan_bit = transfer ( Z '7FC00000' , 1. ) #endif ! this is equivalent to transfer() by Fortran 2003 !nan_bit = real(z'7fc00000') ! however, you will get Error: Result of FLOAT is NaN so use transfer() for the case where you're deliberately setting NaN ! --------- print results ISP = transfer ( nan_sp , ISP ) IDP = transfer ( nan_dp , IDP ) print * , 'IEEE  value  isnan  hex' print '(A4,2X,F5.1,6X,L1,2X,Z32)' , 'sp' , nan_sp , ieee_is_nan ( nan_sp ), ISP print '(A4,2X,F5.1,6X,L1,2X,Z32)' , 'dp' , nan_dp , ieee_is_nan ( nan_dp ), IDP #if REAL128 print '(A4,2X,F5.1,6X,L1,2X,Z32)' , 'qp' , nan_qp , ieee_is_nan ( nan_qp ), nan_qp print '(A4,2X,F5.1,6X,L1,2X,Z32)' , 'zp' , real ( nan_zp ), ieee_is_nan ( real ( nan_zp )), nan_zp print '(A4,2X,F5.1,6X,L1,2X,Z32)' , 'zqp' , real ( nan_zqp ), ieee_is_nan ( real ( nan_zqp )), nan_zqp #endif #if IEEENAN print '(A4,2X,F5.1,6X,L1,2X,Z32)' , 'bit' , nan_bit , ieee_is_nan ( nan_bit ), nan_bit #endif !ieee_is_nan works on real part only, by the bit pattern definition. ! for single prec.: ! gfortran 8.0: FFC00000 ! ifort 18.0: 7FC00000 end program test_nan","tags":"","loc":"sourcefile/nans.f90.html"},{"title":"huge_precision.F90 – Fortran 2018 examples","text":"Contents Programs huge_prec Source Code huge_precision.F90 Source Code program huge_prec use , intrinsic :: iso_fortran_env , stderr => error_unit implicit none ! real128 is enabled but buggy in Gfortran 4.8. Better use Gfortran >= 5. ! shows pitfall of not being mindful with input Kind. Need to be decimal for real kinds! ! \"HUGE(X) returns the largest number that is not an infinity in the type of X\" ! Compare with S. 5.19, pg. 87 of \"Introduction to Programming with Fortran: With Coverage of Fortran 90, 95, 2003, 2008 and 77\", 3rd. Ed., ! By Ian Chivers, Jane Sleightholme\" real ( real32 ), parameter :: huge32 = huge ( 1.0_real32 ) real ( real64 ), parameter :: huge64 = huge ( 1.0_real64 ) #if REAL128 real ( real128 ), parameter :: huge128 = huge ( 1.0_real128 ) complex ( real128 ), parameter :: ch256 = ( huge128 , huge128 ) #endif integer ( int64 ), parameter :: hugeint64 = huge ( 1_int64 ) ! check 32-bit real if ( storage_size ( huge32 ) /= 32 ) then write ( stderr , * ) 'expected 32-bit real but have' , storage_size ( huge32 ), 'bits.' stop 1 endif if ( huge32 /= 3.40282347E+38 ) write ( stderr , * ) 'warning: huge32 was' , huge32 , 'instead of 3.40282347E+38' print * , '32-bit real Huge' , huge32 ! Check 64-bit real if ( storage_size ( huge64 ) /= 64 ) then write ( stderr , * ) 'expected 64-bit real but have' , storage_size ( huge64 ), 'bits.' stop 1 endif if ( huge64 /= 1.7976931348623157E+308_real64 ) write ( stderr , * ) 'warning: huge64 was ' , huge64 , 'instead of 1.7976931348623157E+308' print * , '64-bit real Huge' , huge64 #if REAL128 ! Check 128-bit real if ( storage_size ( huge128 ) /= 128 ) then write ( stderr , * ) 'expected 128-bit real but have' , storage_size ( huge128 ), 'bits.' stop 1 endif if ( huge128 /= 1.18973149535723176508575932662800702E+4932_real128 ) write ( stderr , * ) 'warning: huge128 was ' , huge128 ,& 'instead of 1.18973149535723176508575932662800702E+4932' print * , '128-bit real Huge' , huge128 ! check 256-bit complex if ( storage_size ( ch256 ) /= 256 ) then write ( stderr , * ) 'expected 256-bit complex but have' , storage_size ( ch256 ), 'bits.' stop 1 endif if ( ch256 /= ( huge128 , huge128 )) write ( stderr , * ) 'warning: complex256 was ' , ch256 ,& 'instead of (1.18973149535723176508575932662800702E+4932,1.18973149535723176508575932662800702E+4932)' print * , '256-bit complex huge' , ch256 , 'consisting of' , storage_size ( ch256 ), 'bits' #endif ! Check 64-bit int if ( storage_size ( hugeint64 ) /= 64 ) then write ( stderr , * ) 'expected 64-bit integer but have' , storage_size ( hugeint64 ), 'bits.' stop 1 endif if ( hugeint64 /= 9223372036854775807_int64 ) write ( stderr , * ) 'warning: hugeint64 was ' , hugeint64 , 'instead of 9223372036854775807' print * , '64-bit integer Huge' , hugeint64 ! Must use decimal point inside Huge() or you'll get INCORRECT: ! 32-bit Huge INCORRECT   2.14748365E+09 ! 64-bit Huge INCORRECT  9.2233720368547758E+018 ! 128-bit Huge INCORRECT  1.70141183460469231731687303715884106E+0038 ! CORRECT ! 32-bit Huge   3.40282347E+38 ! 64-bit Huge   1.7976931348623157E+308 ! 128-bit Huge   1.18973149535723176508575932662800702E+4932 ! 64-bit Huge Integer  9223372036854775807 end program","tags":"","loc":"sourcefile/huge_precision.f90.html"},{"title":"fib3.F90 – Fortran 2018 examples","text":"This file depends on sourcefile~~fib3.f90~~EfferentGraph sourcefile~fib3.f90 fib3.F90 sourcefile~assert.f90 assert.F90 sourcefile~fib3.f90->sourcefile~assert.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~fib3.f90~~AfferentGraph sourcefile~fib3.f90 fib3.F90 sourcefile~not-finite.f90 not-finite.f90 sourcefile~not-finite.f90->sourcefile~fib3.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules fib3 Source Code fib3.F90 Source Code module fib3 ! https://gcc.gnu.org/onlinedocs/gfortran/ISO_005fC_005fBINDING.html use , intrinsic :: iso_c_binding , only : real32 => C_FLOAT , real64 => C_DOUBLE , qp => c_long_double use assert , only : wp implicit none contains pure function FIB ( n ) !     CALCULATE FIRST N FIBONACCI NUMBERS integer , intent ( in ) :: n real ( wp ), dimension ( n ) :: fib integer i fib (: 2 ) = [ 0 , 1 ] do I = 3 , N fib ( I ) = fib ( I - 1 ) + fib ( I - 2 ) enddo end function fib end module","tags":"","loc":"sourcefile/fib3.f90.html"},{"title":"div_precision.F90 – Fortran 2018 examples","text":"Contents Programs prec Source Code div_precision.F90 Source Code program prec use , intrinsic :: iso_fortran_env , stderr => error_unit implicit none ! shows pitfall of not being mindful with input Kind ! NOTE that 9/5.0_dp  /=  9/5.0, even when the assigned variable is real(dp) !! ! NOTE: using gfortran option \"-fdefault-real-8\" fixes these problems! ! NOTE: using ifort option \"-r8\" fixes these problems! real ( real32 ) :: huge32 = 9 / 5.0_real32 real ( real64 ) :: huge64 = 9 / 5.0_real64 #if REAL128 real ( real128 ) :: huge128 = 9 / 5.0_real128 #endif integer ( int64 ) :: hugeint64 = 9 / 5_int64 real ( real64 ) :: imdouble = 9 / 5. integer ( int64 ) :: J , K print * , compiler_version () if ( storage_size ( imdouble ) /= 64 ) then write ( stderr , * ) 'expected real64 but you have real bits: ' , storage_size ( imdouble ) stop 1 endif print * , '64-bit variable with 32-bit constants' , imdouble if ( storage_size ( huge64 ) /= 64 ) then write ( stderr , * ) 'expected real64 but you have real bits: ' , storage_size ( huge64 ) stop 1 endif print * , '64-bit' , huge64 print * , '64-bit variable, 32-bit constants equal to all 64-bit constants?' , imdouble == huge64 if ( storage_size ( huge32 ) /= 32 ) then write ( stderr , * ) 'expected real32 but you have real bits: ' , storage_size ( huge32 ) stop 1 endif print * , '32-bit' , huge32 #if REAL128 if ( storage_size ( huge128 ) /= 128 ) then write ( stderr , * ) 'expected real128 but you have real bits: ' , storage_size ( huge128 ) stop 1 endif print * , '128-bit' , huge128 #endif if ( storage_size ( hugeint64 ) /= 64 ) then write ( stderr , * ) 'expected int64 but you have integer bits: ' , storage_size ( hugeint64 ) stop 1 endif print * , '64-bit Integer ' , hugeint64 !  64-bit variable with 32-bit constants   1.7999999523162842 ! 64-bit variable, 32-bit constants equal to all 64-bit constants? F ! 32-bit   1.79999995 ! 64-bit   1.8000000000000000 ! 128-bit   1.80000000000000000000000000000000004 ! 64-bit Integer                    1 ! kinds  sp dp qp i64 !           4           8          16           8 ! Bit Patterns: ! 11011011111111111100110011001100110011000000000000000000000000000000 ! 11011011111111111100110011001100110011001100110011001100110011001101 J = transfer ( imdouble , J ) K = transfer ( huge64 , K ) print * , 'Bit Patterns:' print '(A,B64)' , '64-bit variable with 32-bit constants ' , J print '(A,B64)' , '64-bit variable with 64-bit constants ' , K end program","tags":"","loc":"sourcefile/div_precision.f90.html"},{"title":"assert.F90 – Fortran 2018 examples","text":"Files dependent on this one sourcefile~~assert.f90~~AfferentGraph sourcefile~assert.f90 assert.F90 sourcefile~fib3.f90 fib3.F90 sourcefile~fib3.f90->sourcefile~assert.f90 sourcefile~not-finite.f90 not-finite.f90 sourcefile~not-finite.f90->sourcefile~assert.f90 sourcefile~not-finite.f90->sourcefile~fib3.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules assert Source Code assert.F90 Source Code module assert ! Gfortran >= 6 needed for ieee_arithmetic: ieee_is_nan use , intrinsic :: iso_fortran_env , stderr => error_unit use , intrinsic :: ieee_arithmetic implicit none private #if REALBITS==32 integer , parameter :: wp = real32 #elif REALBITS==64 integer , parameter :: wp = real64 #elif REALBITS==128 integer , parameter :: wp = real128 #endif public :: wp , isclose , assert_isclose contains elemental logical function isclose ( actual , desired , rtol , atol , equal_nan ) ! inputs ! ------ ! actual: value \"measured\" ! desired: value \"wanted\" ! rtol: relative tolerance ! atol: absolute tolerance ! equal_nan: consider NaN to be equal? ! !  rtol overrides atol when both are specified ! ! https://www.python.org/dev/peps/pep-0485/#proposed-implementation ! https://github.com/PythonCHB/close_pep/blob/master/is_close.py real ( wp ), intent ( in ) :: actual , desired real ( wp ), intent ( in ), optional :: rtol , atol logical , intent ( in ), optional :: equal_nan real ( wp ) :: r , a logical :: n ! this is appropriate INSTEAD OF merge(), since non present values aren't defined. r = 1 e - 5_wp a = 0._wp n = . false . if ( present ( rtol )) r = rtol if ( present ( atol )) a = atol if ( present ( equal_nan )) n = equal_nan !print*,r,a,n,actual,desired !--- sanity check if (( r < 0._wp ). or .( a < 0._wp )) error stop !--- simplest case isclose = ( actual == desired ) if ( isclose ) return !--- equal nan isclose = n . and .( ieee_is_nan ( actual ). and . ieee_is_nan ( desired )) if ( isclose ) return !--- Inf /= -Inf, unequal NaN if (. not . ieee_is_finite ( actual ) . or . . not . ieee_is_finite ( desired )) return !--- floating point closeness check isclose = abs ( actual - desired ) <= max ( r * max ( abs ( actual ), abs ( desired )), a ) end function isclose impure elemental subroutine assert_isclose ( actual , desired , rtol , atol , equal_nan , err_msg ) ! inputs ! ------ ! actual: value \"measured\" ! desired: value \"wanted\" ! rtol: relative tolerance ! atol: absolute tolerance ! equal_nan: consider NaN to be equal? ! err_msg: message to print on mismatch ! ! rtol overrides atol when both are specified real ( wp ), intent ( in ) :: actual , desired real ( wp ), intent ( in ), optional :: rtol , atol logical , intent ( in ), optional :: equal_nan character ( * ), intent ( in ), optional :: err_msg if (. not . isclose ( actual , desired , rtol , atol , equal_nan )) then write ( stderr , * ) merge ( err_msg , '' , present ( err_msg )), ': actual' , actual , 'desired' , desired error stop endif end subroutine assert_isclose end module assert","tags":"","loc":"sourcefile/assert.f90.html"},{"title":"polymorphic.F90 – Fortran 2018 examples","text":"Contents Programs polymorphism Source Code polymorphic.F90 Source Code Program polymorphism ! Polymorphic-like real kind at compile time by using preprocessing ! ! Output: ! cmake -Drealbits=32      2pi   6.28318548 ! cmake -Drealbits=64      2pi   6.2831853071795862 ! cmake -Drealbits=128     2pi   6.28318530717958647692528676655900559 use , intrinsic :: iso_fortran_env implicit none #if REALBITS==32 integer , parameter :: wp = real32 #elif REALBITS==64 integer , parameter :: wp = real64 #elif REALBITS==128 integer , parameter :: wp = real128 #endif real ( wp ), parameter :: pi = 4._wp * atan ( 1._wp ) print * , '2pi' , timestwo ( pi ) contains elemental real ( wp ) function timestwo ( a ) result ( a2 ) real ( wp ), intent ( in ) :: a a2 = 2 * a end function timestwo end program","tags":"","loc":"sourcefile/polymorphic.f90.html"},{"title":"floating_precision.F90 – Fortran 2018 examples","text":"Contents Programs float_prec Source Code floating_precision.F90 Source Code program float_prec use , intrinsic :: iso_fortran_env , stderr => error_unit implicit none real ( real32 ) :: pi32 = 4 * atan ( 1.0_real32 ) real ( real64 ) :: pi64 = 4 * atan ( 1.0_real64 ) #if REAL128 real ( real128 ) :: pi128 = 4 * atan ( 1.0_real128 ) #endif print * , compiler_version () if ( storage_size ( pi64 ) /= 64 ) then write ( stderr , * ) 'expected real64 but you have real bits: ' , storage_size ( pi64 ) stop 1 endif print * , '64-bit PI' , pi64 if ( storage_size ( pi32 ) /= 32 ) then write ( stderr , * ) 'expected real32 but you have real bits: ' , storage_size ( pi32 ) stop 1 endif print * , '32-bit PI' , pi32 #if REAL128 if ( storage_size ( pi128 ) /= 128 ) then write ( stderr , * ) 'expected real128 but you have real bits: ' , storage_size ( pi128 ) stop 1 endif print * , '128-bit PI' , pi128 #endif ! output should be: ! 32-bit PI   3.14159274 ! 64-bit PI   3.1415926535897931 ! 128-bit PI   3.14159265358979323846264338327950280 ! both ifort and gfortran allows \"q\" to specify real128 literal, \"d\" to specify real64 literal, and \"e\" for real32 literal. ! One should use \"e\" as the separator and a trailing _wp to avoid silent type conflicts ! this line is only true for default real32 print * , 'default real32  ' , 3.14159265358979323846264338327950280 == 3.14159274 end program","tags":"","loc":"sourcefile/floating_precision.f90.html"},{"title":"polymorphic_module.f90 – Fortran 2018 examples","text":"Contents Programs test2 Modules funcs Source Code polymorphic_module.f90 Source Code module funcs use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 implicit none ! takes affect for all procedures within module interface addtwo procedure addtwo_s , addtwo_d , addtwo_i end interface addtwo contains elemental real ( sp ) function addtwo_s ( x ) result ( y ) real ( sp ), intent ( in ) :: x y = x + 2 end function addtwo_s elemental real ( dp ) function addtwo_d ( x ) result ( y ) real ( dp ), intent ( in ) :: x y = x + 2 end function addtwo_d elemental integer function addtwo_i ( x ) result ( y ) integer , intent ( in ) :: x y = x + 2 end function addtwo_i end module funcs program test2 use funcs implicit none real ( sp ) :: twos = 2._sp real ( dp ) :: twod = 2._dp integer :: twoi = 2 print * , addtwo ( twos ), addtwo ( twod ), addtwo ( twoi ) end program","tags":"","loc":"sourcefile/polymorphic_module.f90.html"},{"title":"precision_problems.F90 – Fortran 2018 examples","text":"Contents Programs precision_problems Source Code precision_problems.F90 Source Code program precision_problems use , intrinsic :: iso_fortran_env , only : wp => real32 implicit none ! look at classic problems with any floating point usages. ! To save agony, it's best for EVERY float constant to have a decimal point and _wp after EACH float number in an equation. real ( wp ), parameter :: me = 9.10938356e-31_wp , mebad = 9.10938356_wp * 10 ** ( - 31 ) print * , 'electron rest mass is' , me , 'kg., not' , mebad end program","tags":"","loc":"sourcefile/precision_problems.f90.html"},{"title":"not-finite.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~not-finite.f90~~EfferentGraph sourcefile~not-finite.f90 not-finite.f90 sourcefile~fib3.f90 fib3.F90 sourcefile~not-finite.f90->sourcefile~fib3.f90 sourcefile~assert.f90 assert.F90 sourcefile~not-finite.f90->sourcefile~assert.f90 sourcefile~fib3.f90->sourcefile~assert.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs testall Source Code not-finite.f90 Source Code program testall use , intrinsic :: ieee_arithmetic use , intrinsic :: iso_fortran_env , only : stderr => error_unit , sp => real32 , dp => real64 , qp => real128 use fib3 , only : fib use assert , only : wp , isclose , assert_isclose implicit none real ( wp ), parameter :: pi = 4. * atan ( 1._wp ) real ( wp ) :: nan , inf ! NOTE: this triggers nuisance exceptions IEEE_INVALID_FLAG, IEEE_OVERFLOW_FLAG nan = ieee_value ( 1._wp , ieee_quiet_nan ) inf = ieee_value ( 1._wp , ieee_positive_inf ) !-------------------------------------------- !------ Assert if ( isclose ( - pi , pi )) error stop call assert_isclose ( ieee_next_after ( pi , 0. ), pi , err_msg = 'very close fail' ) call assert_isclose ( pi + 0.001 , pi , rtol = 0.001_wp , atol = 0.0001_wp , err_msg = 'tolerance fail' ) call assert_isclose ( nan , nan , equal_nan = . true ., err_msg = 'NaN request equality fail' ) call assert_isclose ( nan , - nan , equal_nan = . true ., err_msg = '+NaN -Nan request equality fail' ) if ( isclose ( nan , nan )) error stop 'non-equal NaN failure' call assert_isclose ( inf , inf , err_msg = 'assert +inf equality fail' ) if ( isclose ( - inf , inf )) error stop 'assert -inf  +inf inequality fail' call assert_isclose ( - inf , - inf , err_msg = 'assert -inf equality fail' ) if ( isclose ( nan , inf )) error stop if ( isclose ( inf , nan )) error stop ! denormal ! ifort needs special options to handle these denormal if ( wp == sp . and . isclose ( 1 e - 38_wp , 0._wp , atol = 0._wp )) error stop 'single precision denormal' if ( wp == dp . and . isclose ( 1 e - 308_wp , 0._wp , atol = 0._wp )) error stop 'double precision denormal' if ( wp == qp . and . isclose ( 1 e - 4932_wp , 0._wp , atol = 0._wp )) error stop 'quad precision denormal' ! tiny: 32, 64, 128 bits: ! 1.17549435E-38   2.2250738585072014E-308   3.36210314311209350626267781732175260E-4932 !print*,nan,inf !------- !--------- Fibonacci call assert_isclose ( fib ( 10 ),[ 0._wp , 1._wp , 1._wp , 2._wp , 3._wp , 5._wp , 8._wp , 1 3._wp , 2 1._wp , 3 4._wp ], err_msg = 'fibonacci fail' ) print * , 'Finite precision: test OK' end program","tags":"","loc":"sourcefile/not-finite.f90.html"},{"title":"timeprec.f90 – Fortran 2018 examples","text":"Contents Programs wait_precision Source Code timeprec.f90 Source Code program wait_precision ! demonstrates  timing methods use , intrinsic :: iso_fortran_env , only : dp => real64 , int64 integer ( int64 ) :: tic , toc , rate call system_clock ( tic , count_rate = rate ) call timempi () call system_clock ( toc ) print '(A,ES12.5,A)' , 'instrinsic time: ' ,( toc - tic ) / real ( rate , dp ), ' seconds.' contains subroutine timempi () use omp_lib integer :: Ncore , Nthread real ( dp ) :: tic , toc , rate rate = omp_get_wtick () print '(A,ES10.3,A)' , 'OpenMP tick time: ' , rate , ' second.' !$omp parallel private(tic,toc) tic = omp_get_wtime () ! left these statements here to give a little entropy to per-thread timing. Ncore = omp_get_num_procs () Nthread = omp_get_num_threads () !$omp master print * , Nthread , 'CPU threads used.' , Ncore , ' processor cores detected.' !$omp end master toc = omp_get_wtime () print * , 'Thread: ' , omp_get_thread_num (),( toc - tic ) / rate !$omp end parallel end subroutine timempi end program","tags":"","loc":"sourcefile/timeprec.f90.html"},{"title":"ackermann.f90 – Fortran 2018 examples","text":"Contents Programs AckermannPeter Modules Ackp Source Code ackermann.f90 Source Code module Ackp implicit none contains recursive pure integer function Ap ( m , n ) result ( A ) integer , intent ( in ) :: m , n if ( m == 0 ) then A = n + 1 elseif ( n == 0 ) then A = Ap ( m - 1 , 1 ) else A = Ap ( m - 1 , Ap ( m , n - 1 )) end if end function Ap end module Ackp program AckermannPeter use Ackp implicit none integer :: Ack , M , N character ( 8 ) :: buf if ( command_argument_count () /= 2 ) stop 'input M,N positive integers' call get_command_argument ( 1 , buf ) read ( buf , * ) M call get_command_argument ( 2 , buf ) read ( buf , * ) N Ack = Ap ( M , N ) print * , Ack end program AckermannPeter","tags":"","loc":"sourcefile/ackermann.f90.html"},{"title":"play_sound.f90 – Fortran 2018 examples","text":"Contents Programs mysound Source Code play_sound.f90 Source Code ! recommend using all lower case filenames and no spaces. ! plays sound in Fortran 2003+ program mysound use , intrinsic :: iso_fortran_env , only : error_unit implicit none ! configure ffplay -- could make if/else to allow other players character ( * ), parameter :: playexe = 'ffplay' ! -autoexit clips off the end of the sound slightly, but otherwise thread hangs open even after Fortran program ends. character ( * ), parameter :: cmdopts = '-autoexit -loglevel quiet -nodisp' character ( 1000 ) :: fn character ( 1000 ) :: pcmd !logical :: fexist = .false. integer :: ios !, fsize, u=-1 call get_command_argument ( 1 , fn , status = ios ) if ( ios /= 0 ) stop 'please include audio filename in command' !open(newunit=u,file=fn,status='old',iostat=ios,action='read') !if (ios==0) inquire(unit=u,opened=fexist,size=fsize) ! file and not directory !close(u) ! fsize <= 256 is a little arbitrary--seems there's not yet a compiler-standard way to discriminate between files and diretories. !if (.not.fexist .or. ios/=0 .or. fsize<=256) then !    write(error_unit,*) 'did not find FILE ',trim(fn) !    error stop 'file I/O error' !endif pcmd = playexe // ' ' // cmdopts // ' ' // trim ( fn ) print * , trim ( pcmd ) ! for debugging ! exitstat only works for wait=.true. by Fortran 2008 spec. call execute_command_line ( pcmd ) end program","tags":"","loc":"sourcefile/play_sound.f90.html"},{"title":"gitrev.f90 – Fortran 2018 examples","text":"Contents Programs gitrev Subroutines log_gitrev Source Code gitrev.f90 Source Code program gitrev call log_gitrev ( '.' , 'gitrev.log' ) end program subroutine log_gitrev ( dir , logfn ) ! Logs current git revision for reproducibility ! ! Log directory normally is dynamic, for your simultation output ! ! Demonstrates Fortran 2003 Standard character auto-allocation, !   which helps avoid lots of trim() implicit none character ( * ), intent ( in ) :: dir , logfn character (:), allocatable :: logpath logpath = dir // '/' // logfn call execute_command_line ( 'git rev-parse --short HEAD > ' // logpath ) end subroutine log_gitrev","tags":"","loc":"sourcefile/gitrev.f90.html"},{"title":"rot90.f90 – Fortran 2018 examples","text":"Files dependent on this one sourcefile~~rot90.f90~~AfferentGraph sourcefile~rot90.f90 rot90.f90 sourcefile~test_rot90.f90 test_rot90.f90 sourcefile~test_rot90.f90->sourcefile~rot90.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules rotflip Source Code rot90.f90 Source Code module rotflip ! This module provides rot90, flipud, fliplr for Fortran like Matlab and NumPy ! use , intrinsic :: iso_fortran_env , only : error_unit implicit none interface rot90 module procedure rot90_i , rot90_r end interface rot90 interface flip module procedure flip_i , flip_r end interface flip interface flipud module procedure flipud_i , flipud_r end interface flipud interface fliplr module procedure fliplr_i , fliplr_r end interface fliplr contains integer function rot90_i ( A , k ) result ( rot ) ! https://github.com/numpy/numpy/blob/v1.14.2/numpy/lib/function_base.py#L54-L138 integer , intent ( in ) :: A (:,:) integer , intent ( in ), optional :: k dimension :: rot ( size ( A , 1 ), size ( A , 2 )) integer :: r r = 1 if ( present ( k )) r = k select case ( modulo ( r , 4 )) case ( 0 ) rot = A ! unmodified case ( 1 ) rot = transpose ( flip ( A , 1 )) case ( 2 ) rot = flip ( A , 0 ) case ( 3 ) rot = flip ( transpose ( A ), 1 ) end select end function rot90_i real function rot90_r ( A , k ) result ( rot ) ! https://github.com/numpy/numpy/blob/v1.14.2/numpy/lib/function_base.py#L54-L138 real , intent ( in ) :: A (:,:) integer , intent ( in ), optional :: k dimension :: rot ( size ( A , 1 ), size ( A , 2 )) integer :: r r = 1 if ( present ( k )) r = k select case ( modulo ( r , 4 )) case ( 0 ) rot = A ! unmodified case ( 1 ) rot = transpose ( flip ( A , 1 )) case ( 2 ) rot = flip ( A , 0 ) case ( 3 ) rot = flip ( transpose ( A ), 1 ) end select end function rot90_r !------------------------------ integer function flip_i ( A , d ) result ( flip ) integer , intent ( in ) :: A (:,:) integer , intent ( in ) :: d integer :: M , N dimension :: flip ( size ( A , 1 ), size ( A , 2 )) M = size ( A , 1 ) N = size ( A , 2 ) select case ( d ) case ( 0 ) ! flip both dimensions flip = A ( M : 1 : - 1 , N : 1 : - 1 ) case ( 1 ) flip = A ( M : 1 : - 1 , :) case ( 2 ) flip = A (:, N : 1 : - 1 ) case default error stop 'bad flip dimension, 2-D only  (1 or 2), or 0 for both dimensions' end select end function flip_i real function flip_r ( A , d ) result ( flip ) real , intent ( in ) :: A (:,:) integer , intent ( in ) :: d integer :: M , N dimension :: flip ( size ( A , 1 ), size ( A , 2 )) M = size ( A , 1 ) N = size ( A , 2 ) select case ( d ) case ( 0 ) ! flip both dimensions flip = A ( M : 1 : - 1 , N : 1 : - 1 ) case ( 1 ) flip = A ( M : 1 : - 1 , :) case ( 2 ) flip = A (:, N : 1 : - 1 ) case default error stop 'bad flip dimension, 2-D only  (1 or 2), or 0 for both dimensions' end select end function flip_r !------------------ integer function flipud_i ( A ) result ( flipud ) integer , intent ( in ) :: A (:,:) dimension :: flipud ( size ( A , 1 ), size ( A , 2 )) flipud = flip ( A , 1 ) end function flipud_i real function flipud_r ( A ) result ( flipud ) real , intent ( in ) :: A (:,:) dimension :: flipud ( size ( A , 1 ), size ( A , 2 )) flipud = flip ( A , 1 ) end function flipud_r !----------------------------------------- integer function fliplr_i ( A ) result ( fliplr ) integer , intent ( in ) :: A (:,:) dimension :: fliplr ( size ( A , 1 ), size ( A , 2 )) fliplr = flip ( A , 2 ) end function fliplr_i real function fliplr_r ( A ) result ( fliplr ) real , intent ( in ) :: A (:,:) dimension :: fliplr ( size ( A , 1 ), size ( A , 2 )) fliplr = flip ( A , 2 ) end function fliplr_r end module rotflip","tags":"","loc":"sourcefile/rot90.f90.html"},{"title":"intel_dgesvd.f90 – Fortran 2018 examples","text":"Contents Programs intel_svd Source Code intel_dgesvd.f90 Source Code program intel_svd use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 , compiler_version , stderr => error_unit implicit none ! Intel(R) Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, ! Version 19.0.1.144 Build 20181018 ! 64 bits: error mag:   0.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ! GCC version 7.3.0  (system Lapack) ! 64 bits: error mag:   0.000000000000E+00  2.220446049250E-16  4.996003610813E-16 ! GCC version 7.3.0  (MKL 19) ! 64 bits: error mag:   6.952923663893-310  6.941716482845-310  4.940656458412-324 ! pgf90 18.10-0 (system Lapack ! 64 bits: error mag:   0.000000000000E+00  2.220446049250E-16  4.996003610813E-16 ! pgf90 18.10-0 (MKL 19) ! 64 bits: error mag:   0.000000000000E+00  0.000000000000E+00  0.000000000000E+00 ! Flang does not work with system Lapack, may need to compile lapack real ( dp ) :: A ( 3 , 3 ) = reshape ( & [ 1 , 0 , 1 , & - 1 , - 2 , 0 , & 0 , 1 , - 1 ], & shape ( A )) integer :: svdinfo integer , parameter :: M = size ( a , 1 ), N = size ( a , 2 ), Lratio = 5 integer , parameter :: LWORK = LRATIO * M real ( dp ) :: U ( M , M ), VT ( M , M ), SWORK ( LRATIO * M ) real ( dp ) :: ss64 ( M , N ), s64 ( M ), e64 ( M ), maxerr real ( dp ), parameter :: s64ref ( 3 ) = [ 2.460504870018764_dp , 1.699628148275318_dp , 0.239123278256554_dp ] call dgesvd ( 'A' , 'N' , M , M , A , M , SS64 , U , M , VT , M , SWORK , LWORK , svdinfo ) if ( svdinfo /= 0 ) then write ( stderr , * ) 'svd error: ' , svdinfo stop 1 endif s64 = ss64 (:, 1 ) ! NOT DIAG!!!! !e64 = s64 - S64ref print * , compiler_version () print '(I3,A,3ES20.12)' , storage_size ( s64 ), ' bits: error mag: ' , e64 maxerr = maxval ( abs ( e64 )) if ( maxerr > 1 e - 7_dp ) then write ( stderr , * ) 'excessive singular value error' stop 1 endif end program","tags":"","loc":"sourcefile/intel_dgesvd.f90.html"},{"title":"test_rot90.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~test_rot90.f90~~EfferentGraph sourcefile~test_rot90.f90 test_rot90.f90 sourcefile~rot90.f90 rot90.f90 sourcefile~test_rot90.f90->sourcefile~rot90.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs rot90_array Source Code test_rot90.f90 Source Code program rot90_array ! demo rotating a 2-D array 90 degrees clockwise use rotflip , only : rot90 , flipud , fliplr implicit none integer , parameter :: N = 3 integer :: i , iarr ( N , N ), Barr ( 0 : 2 , 0 : 2 ) real :: rarr ( N , N ) iarr = reshape ( & [ 0 , 1 , 2 , & 3 , 4 , 5 , & 6 , 7 , 8 ], & shape ( iarr ), order = [ 2 , 1 ]) rarr = iarr call printarr ( iarr , 'before rot90' ) call printarr ( rot90 ( iarr , 0 ), 'rot90(0)' ) call printarr ( rot90 ( iarr , 1 ), 'rot90(1)' ) call printarr ( rot90 ( iarr , 2 ), 'rot90(2)' ) call printarr ( rot90 ( iarr , 3 ), 'rot90(3)' ) call printarr ( flipud ( iarr ), 'flipud()' ) call printarr ( fliplr ( iarr ), 'fliplr()' ) ! -- test non-default bounds Barr = iarr print * , lbound ( Barr , 1 ) Barr = rot90 ( Barr ) print * , lbound ( Barr , 1 ) ! -- Fortran polymorphic type rarr = iarr rarr = rot90 ( rarr ) contains subroutine printarr ( arr , msg ) integer , intent ( in ) :: arr (:,:) character ( * ), intent ( in ), optional :: msg character ( 5 ) :: frmt write ( frmt , '(A1,I1,A3)' ) '(' , size ( arr , 1 ), 'I1)' if ( present ( msg )) print * , msg do i = 1 , size ( arr , 1 ) print frmt , arr ( i ,:) enddo end subroutine printarr end program","tags":"","loc":"sourcefile/test_rot90.f90.html"},{"title":"intel_gesvd.f90 – Fortran 2018 examples","text":"Contents Programs intel_svd Source Code intel_gesvd.f90 Source Code program intel_svd use lapack95 , only : gesvd use , intrinsic :: iso_fortran_env , only : sp => real32 , dp => real64 , compiler_version , stderr => error_unit implicit none ! Intel(R) Fortran Intel(R) 64 Compiler for applications running on Intel(R) 64, ! Version 19.0.1.144 Build 20181018 ! 64 bits: error mag:  -8.881784197001E-16 -2.220446049250E-16  5.551115123126E-16 ! 32 bits: error mag:   2.384185791016E-07  0.000000000000E+00  5.960464477539E-08 !  GCC version 7.3.0 ! 64 bits: error mag:  -8.881784197001E-16 -2.220446049250E-16  5.551115123126E-16 ! 32 bits: error mag:   2.384185791016E-07  0.000000000000E+00  5.960464477539E-08 ! Flang, PGI  had MKL source compiling or linking difficulties real ( dp ) :: A ( 3 , 3 ) = reshape ( & [ 1 , 0 , 1 , & - 1 , - 2 , 0 , & 0 , 1 , - 1 ], & shape ( A )) integer , parameter :: M = size ( a , 1 ), N = size ( a , 2 ) real ( dp ) :: s64 ( M ), e64 ( M ), maxerr real ( sp ) :: s32 ( M ), a32 ( M , N ), e32 ( M ) A32 = A call gesvd ( A , s64 ) e64 = s64 - [ 2.460504870018764_dp , 1.699628148275318_dp , 0.239123278256554_dp ] print * , compiler_version () print '(I3,A,3ES20.12)' , storage_size ( s64 ), ' bits: error mag: ' , e64 call gesvd ( A32 , s32 ) e32 = s32 - [ 2.460504870018764_sp , 1.699628148275318_sp , 0.239123278256554_sp ] print '(I3,A,3ES20.12)' , storage_size ( s32 ), ' bits: error mag: ' , e32 maxerr = maxval ( abs ( e64 )) if ( maxerr > 1 e - 7_dp ) then write ( stderr , * ) 'excessive singular value error' stop 1 endif end program","tags":"","loc":"sourcefile/intel_gesvd.f90.html"},{"title":"user.f90 – Fortran 2018 examples","text":"Files dependent on this one sourcefile~~user.f90~~AfferentGraph sourcefile~user.f90 user.f90 sourcefile~points.f90 points.f90 sourcefile~points.f90->sourcefile~user.f90 sourcefile~points_basic.f90 points_basic.f90 sourcefile~points_basic.f90->sourcefile~user.f90 sourcefile~geo_basic.f90 geo_basic.f90 sourcefile~geo_basic.f90->sourcefile~user.f90 sourcefile~geo.f90 geo.f90 sourcefile~geo.f90->sourcefile~user.f90 sourcefile~geo_legacy.f90 geo_legacy.f90 sourcefile~geo_legacy.f90->sourcefile~user.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs submod_demo Modules points Submodules geo Source Code user.f90 Source Code module points type :: point real :: x , y end type point interface module function point_dist ( a , b ) result ( distance ) class ( point ), intent ( in ) :: a , b real :: distance end function point_dist end interface end module points submodule ( points ) geo contains module procedure point_dist distance = hypot ( a % x - b % x , a % y - b % y ) end procedure point_dist end submodule geo program submod_demo use , intrinsic :: iso_fortran_env , only : stderr => error_unit use points , only : point , point_dist implicit none type ( point ) :: a , b real :: dist a = point ( 1. , 1. ) b = point ( 3. , 5. ) dist = point_dist ( a , b ) print * , 'distance' , dist if ( abs ( dist - 4.47213602 ) >= 1 e - 5 ) then write ( stderr , * ) 'excessive error in computation' stop 1 endif end program","tags":"","loc":"sourcefile/user.f90.html"},{"title":"points_basic.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~points_basic.f90~~EfferentGraph sourcefile~points_basic.f90 points_basic.f90 sourcefile~user.f90 user.f90 sourcefile~points_basic.f90->sourcefile~user.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs submod_demo Modules points Source Code points_basic.f90 Source Code module points interface module function point_dist ( ax , ay , bx , by ) result ( distance ) real , intent ( in ) :: ax , ay , bx , by real :: distance end function point_dist end interface end module points program submod_demo use , intrinsic :: iso_fortran_env , only : stderr => error_unit use points , only : point_dist implicit none real :: dist , ax , ay , bx , by ax = 1. ay = 1. bx = 3. by = 5. dist = point_dist ( ax , ay , bx , by ) print * , 'distance' , dist if ( abs ( dist - 4.47213602 ) >= 1 e - 5 ) then write ( stderr , * ) 'excessive error in computation' stop 1 endif end program","tags":"","loc":"sourcefile/points_basic.f90.html"},{"title":"basic.f90 – Fortran 2018 examples","text":"Files dependent on this one sourcefile~~basic.f90~~AfferentGraph sourcefile~basic.f90 basic.f90 sourcefile~basic_sub.f90 basic_sub.f90 sourcefile~basic_sub.f90->sourcefile~basic.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs sm Modules demod Source Code basic.f90 Source Code module demod real , parameter :: pi = 4. * atan ( 1. ) real :: tau interface module subroutine hello ( pi , tau ) real , intent ( in ) :: pi real , intent ( out ) :: tau end subroutine hello end interface contains end module demod program sm use demod call hello ( pi , tau ) print * , 'pi=' , pi , 'tau=' , tau end program","tags":"","loc":"sourcefile/basic.f90.html"},{"title":"geo_basic.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~geo_basic.f90~~EfferentGraph sourcefile~geo_basic.f90 geo_basic.f90 sourcefile~user.f90 user.f90 sourcefile~geo_basic.f90->sourcefile~user.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules geo Source Code geo_basic.f90 Source Code submodule ( points ) geo contains module procedure point_dist distance = hypot ( ax - bx , ay - by ) end procedure point_dist end submodule geo","tags":"","loc":"sourcefile/geo_basic.f90.html"},{"title":"points.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~points.f90~~EfferentGraph sourcefile~points.f90 points.f90 sourcefile~user.f90 user.f90 sourcefile~points.f90->sourcefile~user.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs submod_demo Modules points Source Code points.f90 Source Code module points type :: point real :: x , y end type point interface module function point_dist ( a , b ) result ( distance ) class ( point ), intent ( in ) :: a , b real :: distance end function point_dist end interface end module points program submod_demo use , intrinsic :: iso_fortran_env , only : stderr => error_unit use points , only : point , point_dist implicit none type ( point ) :: a , b real :: dist a = point ( 1. , 1. ) b = point ( 3. , 5. ) dist = point_dist ( a , b ) print * , 'distance' , dist if ( abs ( dist - 4.47213602 ) >= 1 e - 5 ) then write ( stderr , * ) 'excessive error in computation' stop 1 endif end program","tags":"","loc":"sourcefile/points.f90.html"},{"title":"geo_legacy.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~geo_legacy.f90~~EfferentGraph sourcefile~geo_legacy.f90 geo_legacy.f90 sourcefile~user.f90 user.f90 sourcefile~geo_legacy.f90->sourcefile~user.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules geo_legacy Source Code geo_legacy.f90 Source Code submodule ( points ) geo_legacy contains module procedure point_dist distance = sqrt (( a % x - b % x ) ** 2 + ( a % y - b % y ) ** 2 ) end procedure point_dist end submodule geo_legacy","tags":"","loc":"sourcefile/geo_legacy.f90.html"},{"title":"minimal.f90 – Fortran 2018 examples","text":"Contents Programs a Modules b Submodules c Source Code minimal.f90 Source Code module b interface module subroutine d end subroutine d end interface end submodule ( b ) c contains module procedure d end end program a end","tags":"","loc":"sourcefile/minimal.f90.html"},{"title":"geo.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~geo.f90~~EfferentGraph sourcefile~geo.f90 geo.f90 sourcefile~user.f90 user.f90 sourcefile~geo.f90->sourcefile~user.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules geo Source Code geo.f90 Source Code submodule ( points ) geo contains module procedure point_dist distance = hypot ( a % x - b % x , a % y - b % y ) end procedure point_dist end submodule geo ! Flang, PGI fail with ! ! also tried below, with no change in Flang, PGI error: !  module function point_dist(a,b) result(distance) !    class(point), intent(in) :: a, b !    real :: distance !    distance = hypot(a%x - b%x, a%y - b%y) !  end function point_dist","tags":"","loc":"sourcefile/geo.f90.html"},{"title":"basic_sub.f90 – Fortran 2018 examples","text":"This file depends on sourcefile~~basic_sub.f90~~EfferentGraph sourcefile~basic_sub.f90 basic_sub.f90 sourcefile~basic.f90 basic.f90 sourcefile~basic_sub.f90->sourcefile~basic.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules submod Source Code basic_sub.f90 Source Code submodule ( demod ) submod contains module procedure hello tau = 2 * pi end procedure hello end submodule submod","tags":"","loc":"sourcefile/basic_sub.f90.html"},{"title":"fun.f90 – Fortran 2018 examples","text":"Contents Modules mytest Source Code fun.f90 Source Code module mytest use , intrinsic :: iso_c_binding , only : dp => c_double , c_int Implicit none contains pure subroutine timestwo ( z , z2 , N ) bind ( c ) ! elemental is not allowed with BIND(C) integer ( c_int ), intent ( in ) :: N real ( dp ), intent ( in ) :: z ( N ) real ( dp ), intent ( out ) :: z2 ( N ) z2 = 2 * z end subroutine timestwo end module mytest","tags":"","loc":"sourcefile/fun.f90.html"},{"title":"point – Fortran 2018 examples ","text":"type, public :: point Contents Variables x y Components Type Visibility Attributes Name Initial real, public :: x real, public :: y","tags":"","loc":"type/point.html"},{"title":"point – Fortran 2018 examples ","text":"type, public :: point Contents Variables x y Components Type Visibility Attributes Name Initial real, public :: x real, public :: y","tags":"","loc":"type/point~2.html"},{"title":"test_dataset1D – Fortran 2018 examples","text":"subroutine test_dataset1D() Uses H5LT HDF5 proc~~test_dataset1d~~UsesGraph proc~test_dataset1d test_dataset1D H5LT H5LT proc~test_dataset1d->H5LT HDF5 HDF5 proc~test_dataset1d->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~test_dataset1d~~CallsGraph proc~test_dataset1d test_dataset1D h5ltmake_dataset_f h5ltmake_dataset_f proc~test_dataset1d->h5ltmake_dataset_f h5open_f h5open_f proc~test_dataset1d->h5open_f h5ltread_dataset_f h5ltread_dataset_f proc~test_dataset1d->h5ltread_dataset_f proc~passed passed proc~test_dataset1d->proc~passed h5fclose_f h5fclose_f proc~test_dataset1d->h5fclose_f h5fcreate_f h5fcreate_f proc~test_dataset1d->h5fcreate_f h5close_f h5close_f proc~test_dataset1d->h5close_f proc~test_begin test_begin proc~test_dataset1d->proc~test_begin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_dataset1d~~CalledByGraph proc~test_dataset1d test_dataset1D program~lite_test lite_test program~lite_test->proc~test_dataset1d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_dataset1d.html"},{"title":"test_dataset2D – Fortran 2018 examples","text":"subroutine test_dataset2D() Uses H5LT HDF5 proc~~test_dataset2d~~UsesGraph proc~test_dataset2d test_dataset2D H5LT H5LT proc~test_dataset2d->H5LT HDF5 HDF5 proc~test_dataset2d->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~test_dataset2d~~CallsGraph proc~test_dataset2d test_dataset2D h5ltmake_dataset_f h5ltmake_dataset_f proc~test_dataset2d->h5ltmake_dataset_f h5open_f h5open_f proc~test_dataset2d->h5open_f h5ltread_dataset_f h5ltread_dataset_f proc~test_dataset2d->h5ltread_dataset_f proc~passed passed proc~test_dataset2d->proc~passed h5fclose_f h5fclose_f proc~test_dataset2d->h5fclose_f h5fcreate_f h5fcreate_f proc~test_dataset2d->h5fcreate_f h5close_f h5close_f proc~test_dataset2d->h5close_f proc~test_begin test_begin proc~test_dataset2d->proc~test_begin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_dataset2d~~CalledByGraph proc~test_dataset2d test_dataset2D program~lite_test lite_test program~lite_test->proc~test_dataset2d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_dataset2d.html"},{"title":"test_dataset3D – Fortran 2018 examples","text":"subroutine test_dataset3D() Uses H5LT HDF5 proc~~test_dataset3d~~UsesGraph proc~test_dataset3d test_dataset3D H5LT H5LT proc~test_dataset3d->H5LT HDF5 HDF5 proc~test_dataset3d->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~test_dataset3d~~CallsGraph proc~test_dataset3d test_dataset3D h5ltmake_dataset_f h5ltmake_dataset_f proc~test_dataset3d->h5ltmake_dataset_f h5open_f h5open_f proc~test_dataset3d->h5open_f h5ltread_dataset_f h5ltread_dataset_f proc~test_dataset3d->h5ltread_dataset_f proc~passed passed proc~test_dataset3d->proc~passed h5ltget_dataset_info_f h5ltget_dataset_info_f proc~test_dataset3d->h5ltget_dataset_info_f h5fclose_f h5fclose_f proc~test_dataset3d->h5fclose_f h5fcreate_f h5fcreate_f proc~test_dataset3d->h5fcreate_f h5close_f h5close_f proc~test_dataset3d->h5close_f proc~test_begin test_begin proc~test_dataset3d->proc~test_begin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_dataset3d~~CalledByGraph proc~test_dataset3d test_dataset3D program~lite_test lite_test program~lite_test->proc~test_dataset3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_dataset3d.html"},{"title":"test_datasets – Fortran 2018 examples","text":"subroutine test_datasets() Uses H5LT HDF5 proc~~test_datasets~~UsesGraph proc~test_datasets test_datasets H5LT H5LT proc~test_datasets->H5LT HDF5 HDF5 proc~test_datasets->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~test_datasets~~CallsGraph proc~test_datasets test_datasets h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~test_datasets->h5ltmake_dataset_int_f h5ltread_dataset_float_f h5ltread_dataset_float_f proc~test_datasets->h5ltread_dataset_float_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~test_datasets->h5ltread_dataset_int_f h5ltfind_dataset_f h5ltfind_dataset_f proc~test_datasets->h5ltfind_dataset_f h5open_f h5open_f proc~test_datasets->h5open_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~test_datasets->h5ltmake_dataset_double_f h5ltmake_dataset_string_f h5ltmake_dataset_string_f proc~test_datasets->h5ltmake_dataset_string_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~test_datasets->h5ltget_dataset_ndims_f proc~passed passed proc~test_datasets->proc~passed h5ltread_dataset_double_f h5ltread_dataset_double_f proc~test_datasets->h5ltread_dataset_double_f h5ltget_dataset_info_f h5ltget_dataset_info_f proc~test_datasets->h5ltget_dataset_info_f h5ltmake_dataset_float_f h5ltmake_dataset_float_f proc~test_datasets->h5ltmake_dataset_float_f h5fclose_f h5fclose_f proc~test_datasets->h5fclose_f h5fcreate_f h5fcreate_f proc~test_datasets->h5fcreate_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~test_datasets->h5ltread_dataset_string_f h5close_f h5close_f proc~test_datasets->h5close_f proc~test_begin test_begin proc~test_datasets->proc~test_begin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_datasets~~CalledByGraph proc~test_datasets test_datasets program~lite_test lite_test program~lite_test->proc~test_datasets Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_datasets.html"},{"title":"test_attributes – Fortran 2018 examples","text":"subroutine test_attributes() Uses H5LT HDF5 proc~~test_attributes~~UsesGraph proc~test_attributes test_attributes H5LT H5LT proc~test_attributes->H5LT HDF5 HDF5 proc~test_attributes->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~test_attributes~~CallsGraph proc~test_attributes test_attributes h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~test_attributes->h5ltmake_dataset_int_f h5ltget_attribute_double_f h5ltget_attribute_double_f proc~test_attributes->h5ltget_attribute_double_f h5ltset_attribute_float_f h5ltset_attribute_float_f proc~test_attributes->h5ltset_attribute_float_f h5ltset_attribute_double_f h5ltset_attribute_double_f proc~test_attributes->h5ltset_attribute_double_f h5open_f h5open_f proc~test_attributes->h5open_f h5ltget_attribute_info_f h5ltget_attribute_info_f proc~test_attributes->h5ltget_attribute_info_f proc~test_begin test_begin proc~test_attributes->proc~test_begin h5ltget_attribute_float_f h5ltget_attribute_float_f proc~test_attributes->h5ltget_attribute_float_f proc~passed passed proc~test_attributes->proc~passed h5ltset_attribute_int_f h5ltset_attribute_int_f proc~test_attributes->h5ltset_attribute_int_f h5ltset_attribute_string_f h5ltset_attribute_string_f proc~test_attributes->h5ltset_attribute_string_f h5fclose_f h5fclose_f proc~test_attributes->h5fclose_f h5close_f h5close_f proc~test_attributes->h5close_f h5ltget_attribute_int_f h5ltget_attribute_int_f proc~test_attributes->h5ltget_attribute_int_f h5ltget_attribute_ndims_f h5ltget_attribute_ndims_f proc~test_attributes->h5ltget_attribute_ndims_f h5ltget_attribute_string_f h5ltget_attribute_string_f proc~test_attributes->h5ltget_attribute_string_f h5fcreate_f h5fcreate_f proc~test_attributes->h5fcreate_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~test_attributes~~CalledByGraph proc~test_attributes test_attributes program~lite_test lite_test program~lite_test->proc~test_attributes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_attributes.html"},{"title":"test_begin – Fortran 2018 examples","text":"subroutine test_begin(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Called by proc~~test_begin~~CalledByGraph proc~test_begin test_begin proc~test_datasets test_datasets proc~test_datasets->proc~test_begin proc~test_attributes test_attributes proc~test_attributes->proc~test_begin proc~test_dataset1d test_dataset1D proc~test_dataset1d->proc~test_begin proc~test_dataset2d test_dataset2D proc~test_dataset2d->proc~test_begin proc~test_dataset3d test_dataset3D proc~test_dataset3d->proc~test_begin program~lite_test lite_test program~lite_test->proc~test_datasets program~lite_test->proc~test_attributes program~lite_test->proc~test_dataset1d program~lite_test->proc~test_dataset2d program~lite_test->proc~test_dataset3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/test_begin.html"},{"title":"passed – Fortran 2018 examples","text":"subroutine passed() Arguments None Called by proc~~passed~~CalledByGraph proc~passed passed proc~test_datasets test_datasets proc~test_datasets->proc~passed proc~test_attributes test_attributes proc~test_attributes->proc~passed proc~test_dataset1d test_dataset1D proc~test_dataset1d->proc~passed proc~test_dataset2d test_dataset2D proc~test_dataset2d->proc~passed proc~test_dataset3d test_dataset3D proc~test_dataset3d->proc~passed program~lite_test lite_test program~lite_test->proc~test_datasets program~lite_test->proc~test_attributes program~lite_test->proc~test_dataset1d program~lite_test->proc~test_dataset2d program~lite_test->proc~test_dataset3d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/passed.html"},{"title":"log_gitrev – Fortran 2018 examples","text":"subroutine log_gitrev(dir, logfn) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir character(len=*), intent(in) :: logfn Called by proc~~log_gitrev~~CalledByGraph proc~log_gitrev log_gitrev program~gitrev gitrev program~gitrev->proc~log_gitrev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/log_gitrev.html"},{"title":"timestwo_contig – Fortran 2018 examples","text":"public subroutine timestwo_contig(x, contig) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), contiguous :: x (:,:) logical, intent(out) :: contig Contents None","tags":"","loc":"proc/timestwo_contig.html"},{"title":"timestwo – Fortran 2018 examples","text":"public subroutine timestwo(x, contig) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:,:) logical, intent(out) :: contig Contents None","tags":"","loc":"proc/timestwo.html"},{"title":"randint – Fortran 2018 examples","text":"public impure elemental function randint(lo, hi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lo integer, intent(in) :: hi Return Value integer Called by proc~~randint~~CalledByGraph proc~randint randint proc~random_init random_init proc~random_init->proc~randint interface~random_init random_init interface~random_init->proc~random_init program~randominit randominit program~randominit->interface~random_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/randint.html"},{"title":"random_init – Fortran 2018 examples","text":"interface Calls interface~~random_init~~CallsGraph interface~random_init random_init proc~random_init random_init interface~random_init->proc~random_init proc~randint randint proc~random_init->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~random_init~~CalledByGraph interface~random_init random_init program~randominit randominit program~randominit->interface~random_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine random_init() Implementation → Arguments None","tags":"","loc":"interface/random_init.html"},{"title":"writenc – Fortran 2018 examples","text":"subroutine writenc(fn, dout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn integer, intent(in) :: dout (:,:) Calls proc~~writenc~~CallsGraph proc~writenc writenc nf90_put_var nf90_put_var proc~writenc->nf90_put_var nf90_close nf90_close proc~writenc->nf90_close nf90_def_var nf90_def_var proc~writenc->nf90_def_var nf90_enddef nf90_enddef proc~writenc->nf90_enddef nf90_def_dim nf90_def_dim proc~writenc->nf90_def_dim nf90_create nf90_create proc~writenc->nf90_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~writenc~~CalledByGraph proc~writenc writenc program~simple_xy_wr simple_xy_wr program~simple_xy_wr->proc~writenc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writenc.html"},{"title":"readnc – Fortran 2018 examples","text":"subroutine readnc(fn, dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn integer, intent(out) :: dat (:,:) Calls proc~~readnc~~CallsGraph proc~readnc readnc nf90_inq_varid nf90_inq_varid proc~readnc->nf90_inq_varid nf90_get_var nf90_get_var proc~readnc->nf90_get_var nf90_close nf90_close proc~readnc->nf90_close nf90_open nf90_open proc~readnc->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~readnc~~CalledByGraph proc~readnc readnc program~simple_xy_wr simple_xy_wr program~simple_xy_wr->proc~readnc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/readnc.html"},{"title":"check – Fortran 2018 examples","text":"subroutine check(status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Calls proc~~check~~CallsGraph proc~check check nf90_strerror nf90_strerror proc~check->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check.html"},{"title":"check – Fortran 2018 examples","text":"subroutine check(status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status Calls proc~~check~2~~CallsGraph proc~check~2 check nf90_strerror nf90_strerror proc~check~2->nf90_strerror Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check~2.html"},{"title":"g – Fortran 2018 examples","text":"function g(n, i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value integer Called by proc~~g~~CalledByGraph proc~g g program~st st program~st->proc~g Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/g.html"},{"title":"msg_bad_code – Fortran 2018 examples","text":"subroutine msg_bad_code(txt, b) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: txt text to write if b==0 integer, intent(in), optional :: b just an input value Called by proc~~msg_bad_code~~CalledByGraph proc~msg_bad_code msg_bad_code program~short_circuit_logic short_circuit_logic program~short_circuit_logic->proc~msg_bad_code Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/msg_bad_code.html"},{"title":"usleep – Fortran 2018 examples","text":"interface Called by interface~~usleep~~CalledByGraph interface~usleep usleep program~stdsleep stdsleep program~stdsleep->interface~usleep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. subroutine usleep(us) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: us","tags":"","loc":"interface/usleep.html"},{"title":"h5write – Fortran 2018 examples","text":"public subroutine h5write(filename, dsname, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dsname real(kind=dp), intent(in) :: array (:) Calls proc~~h5write~~CallsGraph proc~h5write h5write h5fclose_f h5fclose_f proc~h5write->h5fclose_f h5fcreate_f h5fcreate_f proc~h5write->h5fcreate_f h5open_f h5open_f proc~h5write->h5open_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~h5write~~CalledByGraph proc~h5write h5write program~hdf5simple hdf5simple program~hdf5simple->proc~h5write Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/h5write.html"},{"title":"fakedata – Fortran 2018 examples","text":"function fakedata(length) Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value real(kind=dp)\n  (length) Called by proc~~fakedata~~CalledByGraph proc~fakedata fakedata program~hdf5simple hdf5simple program~hdf5simple->proc~fakedata Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fakedata.html"},{"title":"usleep – Fortran 2018 examples","text":"interface Called by interface~~usleep~2~~CalledByGraph interface~usleep~2 usleep program~overwrite_stdout overwrite_stdout program~overwrite_stdout->interface~usleep~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. subroutine usleep(us) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: us","tags":"","loc":"interface/usleep~2.html"},{"title":"split – Fortran 2018 examples","text":"pure function split(instr, delm) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=1), intent(in) :: delm Return Value character(len=:),\n  allocatable Called by proc~~split~~CalledByGraph proc~split split program~splitstring splitstring program~splitstring->proc~split Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/split.html"},{"title":"writetime – Fortran 2018 examples","text":"function writetime(u, Nrun) Arguments Type Intent Optional Attributes Name integer, intent(in) :: u integer, intent(in) :: Nrun Return Value real(kind=wp) Called by proc~~writetime~~CalledByGraph proc~writetime writetime program~nulltest~2 nulltest program~nulltest~2->proc~writetime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/writetime.html"},{"title":"expanduser – Fortran 2018 examples","text":"public function expanduser(indir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: indir Return Value character(len=:),\n  allocatable Calls proc~~expanduser~~CallsGraph proc~expanduser expanduser proc~homedir homedir proc~expanduser->proc~homedir Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~expanduser~~CalledByGraph proc~expanduser expanduser program~home home program~home->proc~expanduser Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/expanduser.html"},{"title":"homedir – Fortran 2018 examples","text":"public function homedir() Arguments None Return Value character(len=:),\n  allocatable Called by proc~~homedir~~CalledByGraph proc~homedir homedir proc~expanduser expanduser proc~expanduser->proc~homedir program~home home program~home->proc~expanduser Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/homedir.html"},{"title":"createro – Fortran 2018 examples","text":"subroutine createro(fn) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Called by proc~~createro~~CalledByGraph proc~createro createro program~openreadonly openreadonly program~openreadonly->proc~createro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/createro.html"},{"title":"deletefile – Fortran 2018 examples","text":"subroutine deletefile(fn) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn Called by proc~~deletefile~~CalledByGraph proc~deletefile deletefile program~openreadonly openreadonly program~openreadonly->proc~deletefile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/deletefile.html"},{"title":"FIB – Fortran 2018 examples","text":"public pure function FIB(n) result(fib) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=wp),\n  dimension(n) Called by proc~~fib~~CalledByGraph proc~fib FIB program~testall testall program~testall->proc~fib Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fib.html"},{"title":"isclose – Fortran 2018 examples","text":"public elemental function isclose(actual, desired, rtol, atol, equal_nan) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: actual real(kind=wp), intent(in) :: desired real(kind=wp), intent(in), optional :: rtol real(kind=wp), intent(in), optional :: atol logical, intent(in), optional :: equal_nan Return Value logical Called by proc~~isclose~~CalledByGraph proc~isclose isclose program~testall testall program~testall->proc~isclose proc~assert_isclose assert_isclose program~testall->proc~assert_isclose proc~assert_isclose->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/isclose.html"},{"title":"assert_isclose – Fortran 2018 examples","text":"public impure elemental subroutine assert_isclose(actual, desired, rtol, atol, equal_nan, err_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: actual real(kind=wp), intent(in) :: desired real(kind=wp), intent(in), optional :: rtol real(kind=wp), intent(in), optional :: atol logical, intent(in), optional :: equal_nan character(len=*), intent(in), optional :: err_msg Calls proc~~assert_isclose~~CallsGraph proc~assert_isclose assert_isclose proc~isclose isclose proc~assert_isclose->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~assert_isclose~~CalledByGraph proc~assert_isclose assert_isclose program~testall testall program~testall->proc~assert_isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/assert_isclose.html"},{"title":"timestwo – Fortran 2018 examples","text":"elemental function timestwo(a) result(a2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Return Value real(kind=wp) Called by proc~~timestwo~2~~CalledByGraph proc~timestwo~2 timestwo program~polymorphism polymorphism program~polymorphism->proc~timestwo~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timestwo~2.html"},{"title":"addtwo_s – Fortran 2018 examples","text":"public elemental function addtwo_s(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) Called by proc~~addtwo_s~~CalledByGraph proc~addtwo_s addtwo_s interface~addtwo addtwo interface~addtwo->proc~addtwo_s program~test2 test2 program~test2->interface~addtwo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addtwo_s.html"},{"title":"addtwo_d – Fortran 2018 examples","text":"public elemental function addtwo_d(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) Called by proc~~addtwo_d~~CalledByGraph proc~addtwo_d addtwo_d interface~addtwo addtwo interface~addtwo->proc~addtwo_d program~test2 test2 program~test2->interface~addtwo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addtwo_d.html"},{"title":"addtwo_i – Fortran 2018 examples","text":"public elemental function addtwo_i(x) result(y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value integer Called by proc~~addtwo_i~~CalledByGraph proc~addtwo_i addtwo_i interface~addtwo addtwo interface~addtwo->proc~addtwo_i program~test2 test2 program~test2->interface~addtwo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/addtwo_i.html"},{"title":"addtwo – Fortran 2018 examples","text":"public interface addtwo Calls interface~~addtwo~~CallsGraph interface~addtwo addtwo proc~addtwo_i addtwo_i interface~addtwo->proc~addtwo_i proc~addtwo_s addtwo_s interface~addtwo->proc~addtwo_s proc~addtwo_d addtwo_d interface~addtwo->proc~addtwo_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~addtwo~~CalledByGraph interface~addtwo addtwo program~test2 test2 program~test2->interface~addtwo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures addtwo_s addtwo_d addtwo_i Module Procedures public elemental function addtwo_s (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public elemental function addtwo_d (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public elemental function addtwo_i (x) result(y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value integer","tags":"","loc":"interface/addtwo.html"},{"title":"timempi – Fortran 2018 examples","text":"subroutine timempi() Uses omp_lib proc~~timempi~~UsesGraph proc~timempi timempi omp_lib omp_lib proc~timempi->omp_lib Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments None Calls proc~~timempi~~CallsGraph proc~timempi timempi omp_get_wtick omp_get_wtick proc~timempi->omp_get_wtick omp_get_wtime omp_get_wtime proc~timempi->omp_get_wtime omp_get_num_procs omp_get_num_procs proc~timempi->omp_get_num_procs omp_get_num_threads omp_get_num_threads proc~timempi->omp_get_num_threads omp_get_thread_num omp_get_thread_num proc~timempi->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~timempi~~CalledByGraph proc~timempi timempi program~wait_precision wait_precision program~wait_precision->proc~timempi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/timempi.html"},{"title":"Ap – Fortran 2018 examples","text":"public pure recursive function Ap(m, n) result(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer Called by proc~~ap~~CalledByGraph proc~ap Ap proc~ap->proc~ap program~ackermannpeter AckermannPeter program~ackermannpeter->proc~ap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ap.html"},{"title":"rot90_i – Fortran 2018 examples","text":"public function rot90_i(A, k) result(rot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer Calls proc~~rot90_i~~CallsGraph proc~rot90_i rot90_i interface~flip flip proc~rot90_i->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rot90_i~~CalledByGraph proc~rot90_i rot90_i interface~rot90 rot90 interface~rot90->proc~rot90_i program~rot90_array rot90_array program~rot90_array->interface~rot90 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rot90_i.html"},{"title":"rot90_r – Fortran 2018 examples","text":"public function rot90_r(A, k) result(rot) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value real Calls proc~~rot90_r~~CallsGraph proc~rot90_r rot90_r interface~flip flip proc~rot90_r->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~rot90_r~~CalledByGraph proc~rot90_r rot90_r interface~rot90 rot90 interface~rot90->proc~rot90_r program~rot90_array rot90_array program~rot90_array->interface~rot90 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/rot90_r.html"},{"title":"flip_i – Fortran 2018 examples","text":"public function flip_i(A, d) result(flip) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer Called by proc~~flip_i~~CalledByGraph proc~flip_i flip_i interface~flip flip interface~flip->proc~flip_i proc~rot90_i rot90_i proc~rot90_i->interface~flip proc~rot90_r rot90_r proc~rot90_r->interface~flip proc~flipud_i flipud_i proc~flipud_i->interface~flip proc~fliplr_r fliplr_r proc~fliplr_r->interface~flip proc~flipud_r flipud_r proc~flipud_r->interface~flip proc~fliplr_i fliplr_i proc~fliplr_i->interface~flip interface~fliplr fliplr interface~fliplr->proc~fliplr_r interface~fliplr->proc~fliplr_i interface~rot90 rot90 interface~rot90->proc~rot90_i interface~rot90->proc~rot90_r interface~flipud flipud interface~flipud->proc~flipud_i interface~flipud->proc~flipud_r program~rot90_array rot90_array program~rot90_array->interface~fliplr program~rot90_array->interface~rot90 program~rot90_array->interface~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flip_i.html"},{"title":"flip_r – Fortran 2018 examples","text":"public function flip_r(A, d) result(flip) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in) :: d Return Value real Called by proc~~flip_r~~CalledByGraph proc~flip_r flip_r interface~flip flip interface~flip->proc~flip_r proc~rot90_i rot90_i proc~rot90_i->interface~flip proc~rot90_r rot90_r proc~rot90_r->interface~flip proc~flipud_i flipud_i proc~flipud_i->interface~flip proc~fliplr_r fliplr_r proc~fliplr_r->interface~flip proc~flipud_r flipud_r proc~flipud_r->interface~flip proc~fliplr_i fliplr_i proc~fliplr_i->interface~flip interface~fliplr fliplr interface~fliplr->proc~fliplr_r interface~fliplr->proc~fliplr_i interface~rot90 rot90 interface~rot90->proc~rot90_i interface~rot90->proc~rot90_r interface~flipud flipud interface~flipud->proc~flipud_i interface~flipud->proc~flipud_r program~rot90_array rot90_array program~rot90_array->interface~fliplr program~rot90_array->interface~rot90 program~rot90_array->interface~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flip_r.html"},{"title":"flipud_i – Fortran 2018 examples","text":"public function flipud_i(A) result(flipud) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer Calls proc~~flipud_i~~CallsGraph proc~flipud_i flipud_i interface~flip flip proc~flipud_i->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flipud_i~~CalledByGraph proc~flipud_i flipud_i interface~flipud flipud interface~flipud->proc~flipud_i program~rot90_array rot90_array program~rot90_array->interface~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flipud_i.html"},{"title":"flipud_r – Fortran 2018 examples","text":"public function flipud_r(A) result(flipud) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real Calls proc~~flipud_r~~CallsGraph proc~flipud_r flipud_r interface~flip flip proc~flipud_r->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~flipud_r~~CalledByGraph proc~flipud_r flipud_r interface~flipud flipud interface~flipud->proc~flipud_r program~rot90_array rot90_array program~rot90_array->interface~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/flipud_r.html"},{"title":"fliplr_i – Fortran 2018 examples","text":"public function fliplr_i(A) result(fliplr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer Calls proc~~fliplr_i~~CallsGraph proc~fliplr_i fliplr_i interface~flip flip proc~fliplr_i->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fliplr_i~~CalledByGraph proc~fliplr_i fliplr_i interface~fliplr fliplr interface~fliplr->proc~fliplr_i program~rot90_array rot90_array program~rot90_array->interface~fliplr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fliplr_i.html"},{"title":"fliplr_r – Fortran 2018 examples","text":"public function fliplr_r(A) result(fliplr) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real Calls proc~~fliplr_r~~CallsGraph proc~fliplr_r fliplr_r interface~flip flip proc~fliplr_r->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~fliplr_r~~CalledByGraph proc~fliplr_r fliplr_r interface~fliplr fliplr interface~fliplr->proc~fliplr_r program~rot90_array rot90_array program~rot90_array->interface~fliplr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fliplr_r.html"},{"title":"rot90 – Fortran 2018 examples","text":"public interface rot90 Calls interface~~rot90~~CallsGraph interface~rot90 rot90 proc~rot90_r rot90_r interface~rot90->proc~rot90_r proc~rot90_i rot90_i interface~rot90->proc~rot90_i interface~flip flip proc~rot90_r->interface~flip proc~rot90_i->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~rot90~~CalledByGraph interface~rot90 rot90 program~rot90_array rot90_array program~rot90_array->interface~rot90 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures rot90_i rot90_r Module Procedures public function rot90_i (A, k) result(rot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer public function rot90_r (A, k) result(rot) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value real","tags":"","loc":"interface/rot90.html"},{"title":"flip – Fortran 2018 examples","text":"public interface flip Calls interface~~flip~~CallsGraph interface~flip flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~flip~~CalledByGraph interface~flip flip proc~rot90_i rot90_i proc~rot90_i->interface~flip proc~rot90_r rot90_r proc~rot90_r->interface~flip proc~flipud_i flipud_i proc~flipud_i->interface~flip proc~fliplr_r fliplr_r proc~fliplr_r->interface~flip proc~flipud_r flipud_r proc~flipud_r->interface~flip proc~fliplr_i fliplr_i proc~fliplr_i->interface~flip interface~fliplr fliplr interface~fliplr->proc~fliplr_r interface~fliplr->proc~fliplr_i interface~rot90 rot90 interface~rot90->proc~rot90_i interface~rot90->proc~rot90_r interface~flipud flipud interface~flipud->proc~flipud_i interface~flipud->proc~flipud_r program~rot90_array rot90_array program~rot90_array->interface~fliplr program~rot90_array->interface~rot90 program~rot90_array->interface~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures flip_i flip_r Module Procedures public function flip_i (A, d) result(flip) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer public function flip_r (A, d) result(flip) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in) :: d Return Value real","tags":"","loc":"interface/flip.html"},{"title":"flipud – Fortran 2018 examples","text":"public interface flipud Calls interface~~flipud~~CallsGraph interface~flipud flipud proc~flipud_i flipud_i interface~flipud->proc~flipud_i proc~flipud_r flipud_r interface~flipud->proc~flipud_r interface~flip flip proc~flipud_i->interface~flip proc~flipud_r->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~flipud~~CalledByGraph interface~flipud flipud program~rot90_array rot90_array program~rot90_array->interface~flipud Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures flipud_i flipud_r Module Procedures public function flipud_i (A) result(flipud) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function flipud_r (A) result(flipud) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real","tags":"","loc":"interface/flipud.html"},{"title":"fliplr – Fortran 2018 examples","text":"public interface fliplr Calls interface~~fliplr~~CallsGraph interface~fliplr fliplr proc~fliplr_r fliplr_r interface~fliplr->proc~fliplr_r proc~fliplr_i fliplr_i interface~fliplr->proc~fliplr_i interface~flip flip proc~fliplr_r->interface~flip proc~fliplr_i->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~fliplr~~CalledByGraph interface~fliplr fliplr program~rot90_array rot90_array program~rot90_array->interface~fliplr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures fliplr_i fliplr_r Module Procedures public function fliplr_i (A) result(fliplr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function fliplr_r (A) result(fliplr) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real","tags":"","loc":"interface/fliplr.html"},{"title":"printarr – Fortran 2018 examples","text":"subroutine printarr(arr, msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: arr (:,:) character(len=*), intent(in), optional :: msg Called by proc~~printarr~~CalledByGraph proc~printarr printarr program~rot90_array rot90_array program~rot90_array->proc~printarr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/printarr.html"},{"title":"point_dist – Fortran 2018 examples","text":"interface Calls interface~~point_dist~~CallsGraph interface~point_dist point_dist proc~point_dist point_dist interface~point_dist->proc~point_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~point_dist~~CalledByGraph interface~point_dist point_dist program~submod_demo submod_demo program~submod_demo->interface~point_dist program~submod_demo~2 submod_demo program~submod_demo~2->interface~point_dist program~submod_demo~3 submod_demo program~submod_demo~3->interface~point_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module function point_dist(a, b) result(distance) Implementation → Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: a class( point ), intent(in) :: b Return Value real","tags":"","loc":"interface/point_dist.html"},{"title":"point_dist – Fortran 2018 examples","text":"interface public function point_dist(ax, ay, bx, by) result(distance) Arguments Type Intent Optional Attributes Name real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: bx real, intent(in) :: by Return Value real","tags":"","loc":"interface/point_dist~2.html"},{"title":"hello – Fortran 2018 examples","text":"interface Calls interface~~hello~~CallsGraph interface~hello hello proc~hello hello interface~hello->proc~hello Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~hello~~CalledByGraph interface~hello hello program~sm sm program~sm->interface~hello Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine hello(pi, tau) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: pi real, intent(out) :: tau","tags":"","loc":"interface/hello.html"},{"title":"point_dist – Fortran 2018 examples","text":"interface public function point_dist(a, b) result(distance) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: a class( point ), intent(in) :: b Return Value real","tags":"","loc":"interface/point_dist~3.html"},{"title":"d – Fortran 2018 examples","text":"interface Calls interface~~d~~CallsGraph interface~d d proc~d d interface~d->proc~d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module subroutine d() Implementation → Arguments None","tags":"","loc":"interface/d.html"},{"title":"timestwo – Fortran 2018 examples","text":"public pure subroutine timestwo(z, z2, N) bind(c) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: z (N) real(kind=dp), intent(out) :: z2 (N) integer(kind=c_int), intent(in) :: N Contents None","tags":"","loc":"proc/timestwo~3.html"},{"title":"random_init – Fortran 2018 examples","text":"module procedure random_init module subroutine random_init() Interface → Arguments None Calls proc~~random_init~~CallsGraph proc~random_init random_init proc~randint randint proc~random_init->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~random_init~~CalledByGraph proc~random_init random_init interface~random_init random_init interface~random_init->proc~random_init program~randominit randominit program~randominit->interface~random_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/random_init.html"},{"title":"point_dist – Fortran 2018 examples","text":"module procedure point_dist module procedure point_dist() Arguments None Contents None","tags":"","loc":"proc/point_dist~2.html"},{"title":"point_dist – Fortran 2018 examples","text":"module procedure point_dist module function point_dist(a, b) result(distance) Interface → Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: a class( point ), intent(in) :: b Return Value real Called by proc~~point_dist~~CalledByGraph proc~point_dist point_dist interface~point_dist point_dist interface~point_dist->proc~point_dist program~submod_demo submod_demo program~submod_demo->interface~point_dist program~submod_demo~2 submod_demo program~submod_demo~2->interface~point_dist program~submod_demo~3 submod_demo program~submod_demo~3->interface~point_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/point_dist.html"},{"title":"point_dist – Fortran 2018 examples","text":"module procedure point_dist module procedure point_dist() Arguments None Contents None","tags":"","loc":"proc/point_dist~3.html"},{"title":"d – Fortran 2018 examples","text":"module procedure d module subroutine d() Interface → Arguments None Called by proc~~d~~CalledByGraph proc~d d interface~d d interface~d->proc~d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/d.html"},{"title":"point_dist – Fortran 2018 examples","text":"module procedure point_dist module procedure point_dist() Arguments None Contents None","tags":"","loc":"proc/point_dist~4.html"},{"title":"hello – Fortran 2018 examples","text":"module procedure hello module subroutine hello(pi, tau) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: pi real, intent(out) :: tau Called by proc~~hello~~CalledByGraph proc~hello hello interface~hello hello interface~hello->proc~hello program~sm sm program~sm->interface~hello Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/hello.html"},{"title":"contig – Fortran 2018 examples","text":"Uses iso_fortran_env module~~contig~~UsesGraph module~contig contig iso_fortran_env iso_fortran_env module~contig->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~contig~~UsedByGraph module~contig contig program~c c program~c->module~contig Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines timestwo_contig timestwo Subroutines public subroutine timestwo_contig (x, contig) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), contiguous :: x (:,:) logical, intent(out) :: contig public subroutine timestwo (x, contig) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:,:) logical, intent(out) :: contig","tags":"","loc":"module/contig.html"},{"title":"random – Fortran 2018 examples","text":"Used by Descendants: randinit randinit module~~random~~UsedByGraph module~random random program~randominit randominit program~randominit->module~random module~randinit~2 randinit module~randinit~2->module~random module~randinit randinit module~randinit->module~random Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces random_init Functions randint Interfaces interface public module subroutine random_init() Implementation → Arguments None Functions public impure elemental function randint (lo, hi) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lo integer, intent(in) :: hi Return Value integer","tags":"","loc":"module/random.html"},{"title":"h5mod – Fortran 2018 examples","text":"Uses iso_fortran_env h5lt module~~h5mod~~UsesGraph module~h5mod h5mod h5lt h5lt module~h5mod->h5lt iso_fortran_env iso_fortran_env module~h5mod->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~h5mod~~UsedByGraph module~h5mod h5mod program~hdf5simple hdf5simple program~hdf5simple->module~h5mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines h5write Subroutines public subroutine h5write (filename, dsname, array) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=*), intent(in) :: dsname real(kind=dp), intent(in) :: array (:)","tags":"","loc":"module/h5mod.html"},{"title":"fsutils – Fortran 2018 examples","text":"Used by module~~fsutils~~UsedByGraph module~fsutils fsutils program~home home program~home->module~fsutils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions expanduser homedir Functions public function expanduser (indir) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: indir Return Value character(len=:),\n  allocatable public function homedir () Arguments None Return Value character(len=:),\n  allocatable","tags":"","loc":"module/fsutils.html"},{"title":"fib3 – Fortran 2018 examples","text":"Uses iso_c_binding assert module~~fib3~~UsesGraph module~fib3 fib3 iso_c_binding iso_c_binding module~fib3->iso_c_binding module~assert assert module~fib3->module~assert iso_fortran_env iso_fortran_env module~assert->iso_fortran_env ieee_arithmetic ieee_arithmetic module~assert->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~fib3~~UsedByGraph module~fib3 fib3 program~testall testall program~testall->module~fib3 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions FIB Functions public pure function FIB (n) result(fib) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=wp),\n  dimension(n)","tags":"","loc":"module/fib3.html"},{"title":"assert – Fortran 2018 examples","text":"Uses iso_fortran_env ieee_arithmetic module~~assert~~UsesGraph module~assert assert iso_fortran_env iso_fortran_env module~assert->iso_fortran_env ieee_arithmetic ieee_arithmetic module~assert->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~assert~~UsedByGraph module~assert assert program~testall testall program~testall->module~assert module~fib3 fib3 program~testall->module~fib3 module~fib3->module~assert Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions isclose Subroutines assert_isclose Functions public elemental function isclose (actual, desired, rtol, atol, equal_nan) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: actual real(kind=wp), intent(in) :: desired real(kind=wp), intent(in), optional :: rtol real(kind=wp), intent(in), optional :: atol logical, intent(in), optional :: equal_nan Return Value logical Subroutines public impure elemental subroutine assert_isclose (actual, desired, rtol, atol, equal_nan, err_msg) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: actual real(kind=wp), intent(in) :: desired real(kind=wp), intent(in), optional :: rtol real(kind=wp), intent(in), optional :: atol logical, intent(in), optional :: equal_nan character(len=*), intent(in), optional :: err_msg","tags":"","loc":"module/assert.html"},{"title":"funcs – Fortran 2018 examples","text":"Uses iso_fortran_env module~~funcs~~UsesGraph module~funcs funcs iso_fortran_env iso_fortran_env module~funcs->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~funcs~~UsedByGraph module~funcs funcs program~test2 test2 program~test2->module~funcs Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces addtwo Functions addtwo_s addtwo_d addtwo_i Interfaces public interface addtwo public elemental function addtwo_s (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public elemental function addtwo_d (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public elemental function addtwo_i (x) result(y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value integer Functions public elemental function addtwo_s (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x Return Value real(kind=sp) public elemental function addtwo_d (x) result(y) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x Return Value real(kind=dp) public elemental function addtwo_i (x) result(y) Arguments Type Intent Optional Attributes Name integer, intent(in) :: x Return Value integer","tags":"","loc":"module/funcs.html"},{"title":"Ackp – Fortran 2018 examples","text":"Used by module~~ackp~~UsedByGraph module~ackp Ackp program~ackermannpeter AckermannPeter program~ackermannpeter->module~ackp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Ap Functions public pure recursive function Ap (m, n) result(A) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n Return Value integer","tags":"","loc":"module/ackp.html"},{"title":"rotflip – Fortran 2018 examples","text":"Uses iso_fortran_env module~~rotflip~~UsesGraph module~rotflip rotflip iso_fortran_env iso_fortran_env module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~rotflip~~UsedByGraph module~rotflip rotflip program~rot90_array rot90_array program~rot90_array->module~rotflip Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces rot90 flip flipud fliplr Functions rot90_i rot90_r flip_i flip_r flipud_i flipud_r fliplr_i fliplr_r Interfaces public interface rot90 public function rot90_i (A, k) result(rot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer public function rot90_r (A, k) result(rot) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value real public interface flip public function flip_i (A, d) result(flip) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer public function flip_r (A, d) result(flip) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in) :: d Return Value real public interface flipud public function flipud_i (A) result(flipud) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function flipud_r (A) result(flipud) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real public interface fliplr public function fliplr_i (A) result(fliplr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function fliplr_r (A) result(fliplr) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real Functions public function rot90_i (A, k) result(rot) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value integer public function rot90_r (A, k) result(rot) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in), optional :: k Return Value real public function flip_i (A, d) result(flip) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) integer, intent(in) :: d Return Value integer public function flip_r (A, d) result(flip) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) integer, intent(in) :: d Return Value real public function flipud_i (A) result(flipud) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function flipud_r (A) result(flipud) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real public function fliplr_i (A) result(fliplr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: A (:,:) Return Value integer public function fliplr_r (A) result(fliplr) Arguments Type Intent Optional Attributes Name real, intent(in) :: A (:,:) Return Value real","tags":"","loc":"module/rotflip.html"},{"title":"points – Fortran 2018 examples","text":"Used by Descendants: geo geo_legacy geo geo module~~points~2~~UsedByGraph module~points~2 points program~submod_demo submod_demo program~submod_demo->module~points~2 module~geo~2 geo module~geo~2->module~points~2 program~submod_demo~2 submod_demo program~submod_demo~2->module~points~2 module~geo~3 geo module~geo~3->module~points~2 module~geo geo module~geo->module~points~2 program~submod_demo~3 submod_demo program~submod_demo~3->module~points~2 module~geo_legacy geo_legacy module~geo_legacy->module~points~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces point_dist Derived Types point Interfaces interface public module function point_dist(a, b) result(distance) Implementation → Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: a class( point ), intent(in) :: b Return Value real Derived Types type, public :: point Components Type Visibility Attributes Name Initial real, public :: x real, public :: y","tags":"","loc":"module/points~2.html"},{"title":"points – Fortran 2018 examples","text":"Contents Interfaces point_dist Interfaces interface public function point_dist(ax, ay, bx, by) result(distance) Arguments Type Intent Optional Attributes Name real, intent(in) :: ax real, intent(in) :: ay real, intent(in) :: bx real, intent(in) :: by Return Value real","tags":"","loc":"module/points.html"},{"title":"demod – Fortran 2018 examples","text":"Used by Descendants: submod module~~demod~~UsedByGraph module~demod demod module~submod submod module~submod->module~demod program~sm sm program~sm->module~demod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi tau Interfaces hello Variables Type Visibility Attributes Name Initial real, public, parameter :: pi = 4.*atan(1.) real, public :: tau Interfaces interface public module subroutine hello(pi, tau) Implementation → Arguments Type Intent Optional Attributes Name real, intent(in) :: pi real, intent(out) :: tau","tags":"","loc":"module/demod.html"},{"title":"points – Fortran 2018 examples","text":"Contents Interfaces point_dist Derived Types point Interfaces interface public function point_dist(a, b) result(distance) Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: a class( point ), intent(in) :: b Return Value real Derived Types type, public :: point Components Type Visibility Attributes Name Initial real, public :: x real, public :: y","tags":"","loc":"module/points~3.html"},{"title":"b – Fortran 2018 examples","text":"Used by Descendants: c module~~b~~UsedByGraph module~b b module~c c module~c->module~b Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces d Interfaces interface public module subroutine d() Implementation → Arguments None","tags":"","loc":"module/b.html"},{"title":"mytest – Fortran 2018 examples","text":"Uses iso_c_binding module~~mytest~~UsesGraph module~mytest mytest iso_c_binding iso_c_binding module~mytest->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines timestwo Subroutines public pure subroutine timestwo (z, z2, N) bind(c) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: z (N) real(kind=dp), intent(out) :: z2 (N) integer(kind=c_int), intent(in) :: N","tags":"","loc":"module/mytest.html"},{"title":"randinit – Fortran 2018 examples","text":"Uses Ancestors: random module~~randinit~~UsesGraph module~randinit randinit module~random random module~randinit->module~random Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/randinit.html"},{"title":"randinit – Fortran 2018 examples","text":"Uses iso_fortran_env Ancestors: random module~~randinit~2~~UsesGraph module~randinit~2 randinit iso_fortran_env iso_fortran_env module~randinit~2->iso_fortran_env module~random random module~randinit~2->module~random Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures random_init Module Procedures module procedure random_init module subroutine random_init() Interface → Arguments None","tags":"","loc":"module/randinit~2.html"},{"title":"geo – Fortran 2018 examples","text":"Uses Ancestors: points module~~geo~3~~UsesGraph module~geo~3 geo module~points~2 points module~geo~3->module~points~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures point_dist Module Procedures module procedure point_dist module procedure point_dist() Arguments None","tags":"","loc":"module/geo~3.html"},{"title":"geo – Fortran 2018 examples","text":"Uses Ancestors: points module~~geo~~UsesGraph module~geo geo module~points~2 points module~geo->module~points~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures point_dist Module Procedures module procedure point_dist module function point_dist(a, b) result(distance) Interface → Arguments Type Intent Optional Attributes Name class( point ), intent(in) :: a class( point ), intent(in) :: b Return Value real","tags":"","loc":"module/geo.html"},{"title":"geo_legacy – Fortran 2018 examples","text":"Uses Ancestors: points module~~geo_legacy~~UsesGraph module~geo_legacy geo_legacy module~points~2 points module~geo_legacy->module~points~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures point_dist Module Procedures module procedure point_dist module procedure point_dist() Arguments None","tags":"","loc":"module/geo_legacy.html"},{"title":"c – Fortran 2018 examples","text":"Uses Ancestors: b module~~c~~UsesGraph module~c c module~b b module~c->module~b Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures d Module Procedures module procedure d module subroutine d() Interface → Arguments None","tags":"","loc":"module/c.html"},{"title":"geo – Fortran 2018 examples","text":"Uses Ancestors: points module~~geo~2~~UsesGraph module~geo~2 geo module~points~2 points module~geo~2->module~points~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures point_dist Module Procedures module procedure point_dist module procedure point_dist() Arguments None","tags":"","loc":"module/geo~2.html"},{"title":"submod – Fortran 2018 examples","text":"Uses Ancestors: demod module~~submod~~UsesGraph module~submod submod module~demod demod module~submod->module~demod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures hello Module Procedures module procedure hello module subroutine hello(pi, tau) Interface → Arguments Type Intent Optional Attributes Name real, intent(in) :: pi real, intent(out) :: tau","tags":"","loc":"module/submod.html"},{"title":"c – Fortran 2018 examples","text":"Uses iso_fortran_env contig program~~c~~UsesGraph program~c c iso_fortran_env iso_fortran_env program~c->iso_fortran_env module~contig contig program~c->module~contig module~contig->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables N x tic toc rate t1 t2 iscontig1 iscontig2 Variables Type Attributes Name Initial integer, parameter :: N = 1000000 real(kind=dp) :: x (2,N) = 1. integer(kind=i64) :: tic integer(kind=i64) :: toc integer(kind=i64) :: rate real(kind=dp) :: t1 real(kind=dp) :: t2 logical :: iscontig1 logical :: iscontig2","tags":"","loc":"program/c.html"},{"title":"randominit – Fortran 2018 examples","text":"Uses random program~~randominit~~UsesGraph program~randominit randominit module~random random program~randominit->module~random Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~randominit~~CallsGraph program~randominit randominit interface~random_init random_init program~randominit->interface~random_init proc~random_init random_init interface~random_init->proc~random_init proc~randint randint proc~random_init->proc~randint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables r i Variables Type Attributes Name Initial real :: r integer :: i","tags":"","loc":"program/randominit.html"},{"title":"coarray_pi – Fortran 2018 examples","text":"Uses iso_fortran_env program~~coarray_pi~~UsesGraph program~coarray_pi coarray_pi iso_fortran_env iso_fortran_env program~coarray_pi->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp x0 x1 pi psum rate tic toc f x telaps dx i stat im Ni cbuf Variables Type Attributes Name Initial integer, parameter :: wp = dp real(kind=wp), parameter :: x0 = -1.0_wp real(kind=wp), parameter :: x1 = 1.0_wp real(kind=wp), parameter :: pi = 4._wp*atan(1.0_wp) real(kind=wp) :: psum [*] integer(kind=int64) :: rate integer(kind=int64) :: tic integer(kind=int64) :: toc real(kind=wp) :: f real(kind=wp) :: x real(kind=wp) :: telaps real(kind=wp) :: dx integer :: i integer :: stat integer :: im integer :: Ni character(len=16) :: cbuf","tags":"","loc":"program/coarray_pi.html"},{"title":"helloworld – Fortran 2018 examples","text":"Uses iso_fortran_env program~~helloworld~~UsesGraph program~helloworld helloworld iso_fortran_env iso_fortran_env program~helloworld->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables rate tic toc telaps Variables Type Attributes Name Initial integer(kind=int64) :: rate integer(kind=int64) :: tic = 0 integer(kind=int64) :: toc real(kind=dp) :: telaps","tags":"","loc":"program/helloworld.html"},{"title":"coarray_pi – Fortran 2018 examples","text":"Uses iso_fortran_env program~~coarray_pi~2~~UsesGraph program~coarray_pi~2 coarray_pi iso_fortran_env iso_fortran_env program~coarray_pi~2->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables wp x0 x1 pi psum rate tic toc f x telaps dx i stat im Ni cbuf Variables Type Attributes Name Initial integer, parameter :: wp = dp real(kind=wp), parameter :: x0 = -1.0_wp real(kind=wp), parameter :: x1 = 1.0_wp real(kind=wp), parameter :: pi = 4._wp*atan(1.0_wp) real(kind=wp) :: psum [*] integer(kind=int64) :: rate integer(kind=int64) :: tic integer(kind=int64) :: toc real(kind=wp) :: f real(kind=wp) :: x real(kind=wp) :: telaps real(kind=wp) :: dx integer :: i integer :: stat integer :: im integer :: Ni character(len=16) :: cbuf","tags":"","loc":"program/coarray_pi~2.html"},{"title":"simple_xy_wr – Fortran 2018 examples","text":"Uses netcdf program~~simple_xy_wr~~UsesGraph program~simple_xy_wr simple_xy_wr netcdf netcdf program~simple_xy_wr->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~simple_xy_wr~~CallsGraph program~simple_xy_wr simple_xy_wr proc~readnc readnc program~simple_xy_wr->proc~readnc proc~writenc writenc program~simple_xy_wr->proc~writenc nf90_get_var nf90_get_var proc~readnc->nf90_get_var nf90_close nf90_close proc~readnc->nf90_close nf90_inq_varid nf90_inq_varid proc~readnc->nf90_inq_varid nf90_open nf90_open proc~readnc->nf90_open nf90_put_var nf90_put_var proc~writenc->nf90_put_var proc~writenc->nf90_close nf90_def_var nf90_def_var proc~writenc->nf90_def_var nf90_def_dim nf90_def_dim proc~writenc->nf90_def_dim nf90_enddef nf90_enddef proc~writenc->nf90_enddef nf90_create nf90_create proc~writenc->nf90_create Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables fn NDIMS NX NY ncid varid dimids x_dimid y_dimid dout dat x y Subroutines writenc readnc check Variables Type Attributes Name Initial character(len=*), parameter :: fn = \"simple_xy.nc\" integer, parameter :: NDIMS = 2 integer, parameter :: NX = 6 integer, parameter :: NY = 12 integer :: ncid integer :: varid integer :: dimids (NDIMS) integer :: x_dimid integer :: y_dimid integer :: dout (NY,NX) integer :: dat (ny,nx) integer :: x integer :: y Subroutines subroutine writenc (fn, dout) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn integer, intent(in) :: dout (:,:) subroutine readnc (fn, dat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn integer, intent(out) :: dat (:,:) subroutine check (status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status","tags":"","loc":"program/simple_xy_wr.html"},{"title":"simple_xy_rd – Fortran 2018 examples","text":"Uses netcdf program~~simple_xy_rd~~UsesGraph program~simple_xy_rd simple_xy_rd netcdf netcdf program~simple_xy_rd->netcdf Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~simple_xy_rd~~CallsGraph program~simple_xy_rd simple_xy_rd nf90_inq_varid nf90_inq_varid program~simple_xy_rd->nf90_inq_varid nf90_get_var nf90_get_var program~simple_xy_rd->nf90_get_var nf90_close nf90_close program~simple_xy_rd->nf90_close nf90_open nf90_open program~simple_xy_rd->nf90_open Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables fn NX NY data_in ncid varid x y Subroutines check Variables Type Attributes Name Initial character(len=*), parameter :: fn = \"simple_xy.nc\" integer, parameter :: NX = 6 integer, parameter :: NY = 12 integer :: data_in (NY,NX) integer :: ncid integer :: varid integer :: x integer :: y Subroutines subroutine check (status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: status","tags":"","loc":"program/simple_xy_rd.html"},{"title":"main – Fortran 2018 examples","text":"Uses mpi_f08 program~~main~~UsesGraph program~main main mpi_f08 mpi_f08 program~main->mpi_f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~main~~CallsGraph program~main main mpi_finalize mpi_finalize program~main->mpi_finalize mpi_init mpi_init program~main->mpi_init mpi_comm_rank mpi_comm_rank program~main->mpi_comm_rank mpi_comm_size mpi_comm_size program~main->mpi_comm_size mpi_get_library_version mpi_get_library_version program~main->mpi_get_library_version Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ierr mrank msize vlen version Variables Type Attributes Name Initial integer :: ierr integer :: mrank integer :: msize integer :: vlen character(len=MPI_MAX_LIBRARY_VERSION_STRING) :: version","tags":"","loc":"program/main.html"},{"title":"helloworld – Fortran 2018 examples","text":"Uses mpi_f08 iso_fortran_env program~~helloworld~2~~UsesGraph program~helloworld~2 helloworld iso_fortran_env iso_fortran_env program~helloworld~2->iso_fortran_env mpi_f08 mpi_f08 program~helloworld~2->mpi_f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~helloworld~2~~CallsGraph program~helloworld~2 helloworld mpi_wtime mpi_wtime program~helloworld~2->mpi_wtime mpi_finalize mpi_finalize program~helloworld~2->mpi_finalize mpi_init mpi_init program~helloworld~2->mpi_init mpi_comm_rank mpi_comm_rank program~helloworld~2->mpi_comm_rank mpi_comm_size mpi_comm_size program~helloworld~2->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i Nproc wtime Variables Type Attributes Name Initial integer :: i integer :: Nproc real(kind=dp) :: wtime","tags":"","loc":"program/helloworld~2.html"},{"title":"main – Fortran 2018 examples","text":"Uses iso_fortran_env mpi_f08 program~~main~2~~UsesGraph program~main~2 main iso_fortran_env iso_fortran_env program~main~2->iso_fortran_env mpi_f08 mpi_f08 program~main~2->mpi_f08 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~main~2~~CallsGraph program~main~2 main mpi_finalize mpi_finalize program~main~2->mpi_finalize mpi_init mpi_init program~main~2->mpi_init mpi_get_count mpi_get_count program~main~2->mpi_get_count mpi_comm_rank mpi_comm_rank program~main~2->mpi_comm_rank mpi_comm_size mpi_comm_size program~main~2->mpi_comm_size Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables time mcount dat val dest i num_procs rank tag status Variables Type Attributes Name Initial character(len=10) :: time integer :: mcount real :: dat (0:99) real :: val (200) integer :: dest integer :: i integer :: num_procs integer :: rank integer :: tag type(MPI_STATUS) :: status","tags":"","loc":"program/main~2.html"},{"title":"bitpat – Fortran 2018 examples","text":"Uses iso_fortran_env program~~bitpat~~UsesGraph program~bitpat bitpat iso_fortran_env iso_fortran_env program~bitpat->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables I J hexa K K1 Variables Type Attributes Name Initial integer :: I (5) integer, parameter :: J (5) = [2**29, 2**22, 2**15, 2**8, 2**1] integer(kind=int64), parameter :: hexa = int(z'80000000', int64) integer(kind=int64), parameter :: K = int(O\"201004020100\", int64) integer, parameter :: K1 = int(O'50147')","tags":"","loc":"program/bitpat.html"},{"title":"st – Fortran 2018 examples","text":"Calls program~~st~~CallsGraph program~st st proc~g g program~st->proc~g Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables f i j k n Functions g Variables Type Attributes Name Initial integer :: f integer :: i integer :: j integer :: k integer :: n Functions function g (n, i, j, k) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k Return Value integer","tags":"","loc":"program/st.html"},{"title":"short_circuit_logic – Fortran 2018 examples","text":"Fortran does NOT have short-circuit logic , \n but some compilers enact short-circuit logic anyway.\n This can lead to confusion between different users. Compilers will definitely let you compile this, but some will segfault on run.\n NAG will raise Runtime error noting reference to not present variable. Calls program~~short_circuit_logic~~CallsGraph program~short_circuit_logic short_circuit_logic proc~msg_bad_code msg_bad_code program~short_circuit_logic->proc~msg_bad_code Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Subroutines msg_bad_code Subroutines subroutine msg_bad_code (txt, b) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: txt text to write if b==0 integer, intent(in), optional :: b just an input value","tags":"","loc":"program/short_circuit_logic.html"},{"title":"replace_pause – Fortran 2018 examples","text":"Uses iso_fortran_env program~~replace_pause~~UsesGraph program~replace_pause replace_pause iso_fortran_env iso_fortran_env program~replace_pause->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables userinp Variables Type Attributes Name Initial character(len=80) :: userinp","tags":"","loc":"program/replace_pause.html"},{"title":"stdsleep – Fortran 2018 examples","text":"Uses iso_c_binding program~~stdsleep~~UsesGraph program~stdsleep stdsleep iso_c_binding iso_c_binding program~stdsleep->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~stdsleep~~CallsGraph program~stdsleep stdsleep interface~usleep usleep program~stdsleep->interface~usleep Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables us Interfaces usleep Variables Type Attributes Name Initial integer(kind=c_int), parameter :: us = 500000 Interfaces interface subroutine usleep(us) bind(C) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: us","tags":"","loc":"program/stdsleep.html"},{"title":"procprint – Fortran 2018 examples","text":"Uses iso_fortran_env program~~procprint~~UsesGraph program~procprint procprint iso_fortran_env iso_fortran_env program~procprint->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"program/procprint.html"},{"title":"f2018errorstop – Fortran 2018 examples","text":"Uses iso_fortran_env program~~f2018errorstop~~UsesGraph program~f2018errorstop f2018errorstop iso_fortran_env iso_fortran_env program~f2018errorstop->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables r c Variables Type Attributes Name Initial real :: r character(len=10) :: c","tags":"","loc":"program/f2018errorstop.html"},{"title":"h5rw – Fortran 2018 examples","text":"Uses iso_fortran_env hdf5 program~~h5rw~~UsesGraph program~h5rw h5rw iso_fortran_env iso_fortran_env program~h5rw->iso_fortran_env hdf5 hdf5 program~h5rw->hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~h5rw~~CallsGraph program~h5rw h5rw h5screate_simple_f h5screate_simple_f program~h5rw->h5screate_simple_f h5open_f h5open_f program~h5rw->h5open_f h5kind_to_type h5kind_to_type program~h5rw->h5kind_to_type h5fopen_f h5fopen_f program~h5rw->h5fopen_f h5dclose_f h5dclose_f program~h5rw->h5dclose_f h5fclose_f h5fclose_f program~h5rw->h5fclose_f h5fcreate_f h5fcreate_f program~h5rw->h5fcreate_f h5close_f h5close_f program~h5rw->h5close_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables filename dsname fid dset_id dspace_id mspace_id data_dims sp dp ioerr i din dout f_ptr array Variables Type Attributes Name Initial character(len=*), parameter :: filename = \"simple.h5\" character(len=*), parameter :: dsname = \"my_image\" integer(kind=hid_t) :: fid integer(kind=hid_t) :: dset_id integer(kind=hid_t) :: dspace_id integer(kind=hid_t) :: mspace_id integer(kind=hsize_t) :: data_dims (rank) integer, parameter :: sp = selected_real_kind(6, 37) integer, parameter :: dp = selected_real_kind(15, 307) integer :: ioerr integer :: i real(kind=dp), target :: din (9) real(kind=dp), target :: dout (9) type(c_ptr) :: f_ptr real(kind=dp) :: array (9)","tags":"","loc":"program/h5rw.html"},{"title":"hdf5simple – Fortran 2018 examples","text":"Uses iso_fortran_env h5mod program~~hdf5simple~~UsesGraph program~hdf5simple hdf5simple iso_fortran_env iso_fortran_env program~hdf5simple->iso_fortran_env module~h5mod h5mod program~hdf5simple->module~h5mod module~h5mod->iso_fortran_env h5lt h5lt module~h5mod->h5lt Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~hdf5simple~~CallsGraph program~hdf5simple hdf5simple proc~h5write h5write program~hdf5simple->proc~h5write proc~fakedata fakedata program~hdf5simple->proc~fakedata h5fclose_f h5fclose_f proc~h5write->h5fclose_f h5fcreate_f h5fcreate_f proc~h5write->h5fcreate_f h5open_f h5open_f proc~h5write->h5open_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables filename dsname array length ioerr argv Functions fakedata Variables Type Attributes Name Initial character(len=*), parameter :: filename = \"simple.h5\" character(len=*), parameter :: dsname = \"1toN\" real(kind=dp), allocatable :: array (:) integer :: length integer :: ioerr character(len=8) :: argv Functions function fakedata (length) Arguments Type Intent Optional Attributes Name integer, intent(in) :: length Return Value real(kind=dp)\n  (length)","tags":"","loc":"program/hdf5simple.html"},{"title":"RWDSET_FORTRAN2003 – Fortran 2018 examples","text":"Uses iso_c_binding HDF5 program~~rwdset_fortran2003~~UsesGraph program~rwdset_fortran2003 RWDSET_FORTRAN2003 iso_c_binding iso_c_binding program~rwdset_fortran2003->iso_c_binding HDF5 HDF5 program~rwdset_fortran2003->HDF5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~rwdset_fortran2003~~CallsGraph program~rwdset_fortran2003 RWDSET_FORTRAN2003 h5screate_simple_f h5screate_simple_f program~rwdset_fortran2003->h5screate_simple_f h5open_f h5open_f program~rwdset_fortran2003->h5open_f h5kind_to_type h5kind_to_type program~rwdset_fortran2003->h5kind_to_type h5fopen_f h5fopen_f program~rwdset_fortran2003->h5fopen_f h5dclose_f h5dclose_f program~rwdset_fortran2003->h5dclose_f h5fclose_f h5fclose_f program~rwdset_fortran2003->h5fclose_f h5fcreate_f h5fcreate_f program~rwdset_fortran2003->h5fcreate_f h5close_f h5close_f program~rwdset_fortran2003->h5close_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i1 i4 i8 i16 sp dp filename dsetname1 dsetname2 dsetname4 dsetname8 dsetnamer4 dsetnamer8 file_id dset_id1 dset_id4 dset_id8 dset_id16 dset_idr4 dset_idr8 error i dset_data_i1 dset_data_i4 data_out_i4 dset_data_i8 data_out_i8 dset_data_i16 data_out_i16 data_out_i8a dset_data_r7 data_out_r7 dset_data_r15 data_out_r15 data_dims dspace_id f_ptr Variables Type Attributes Name Initial integer, parameter :: i1 = SELECTED_INT_KIND(2) integer, parameter :: i4 = SELECTED_INT_KIND(4) integer, parameter :: i8 = SELECTED_INT_KIND(9) integer, parameter :: i16 = SELECTED_INT_KIND(18) integer, parameter :: sp = SELECTED_REAL_KIND(6, 37) integer, parameter :: dp = SELECTED_REAL_KIND(15, 307) character(len=*), parameter :: filename = \"dsetf.h5\" character(len=*), parameter :: dsetname1 = \"dset1\" character(len=*), parameter :: dsetname2 = \"dset2\" character(len=*), parameter :: dsetname4 = \"dset4\" character(len=*), parameter :: dsetname8 = \"dset8\" character(len=*), parameter :: dsetnamer4 = \"dsetr4\" character(len=*), parameter :: dsetnamer8 = \"dsetr8\" integer(kind=HID_T) :: file_id integer(kind=HID_T) :: dset_id1 integer(kind=HID_T) :: dset_id4 integer(kind=HID_T) :: dset_id8 integer(kind=HID_T) :: dset_id16 integer(kind=HID_T) :: dset_idr4 integer(kind=HID_T) :: dset_idr8 integer :: error integer :: i integer(kind=i1), DIMENSION(1:4), TARGET :: dset_data_i1 integer(kind=i4), DIMENSION(1:4), TARGET :: dset_data_i4 integer(kind=i4), DIMENSION(1:4), TARGET :: data_out_i4 integer(kind=i8), DIMENSION(1:4), TARGET :: dset_data_i8 integer(kind=i8), DIMENSION(1:4), TARGET :: data_out_i8 integer(kind=i16), DIMENSION(1:4), TARGET :: dset_data_i16 integer(kind=i16), DIMENSION(1:4), TARGET :: data_out_i16 integer(kind=i8), DIMENSION(1:4), TARGET :: data_out_i8a real(kind=sp), DIMENSION(1:4), TARGET :: dset_data_r7 real(kind=sp), DIMENSION(1:4), TARGET :: data_out_r7 real(kind=dp), DIMENSION(1:4), TARGET :: dset_data_r15 real(kind=dp), DIMENSION(1:4), TARGET :: data_out_r15 integer(kind=HSIZE_T), DIMENSION(1:1) :: data_dims = (/4/) integer(kind=HID_T) :: dspace_id type(C_PTR) :: f_ptr","tags":"","loc":"program/rwdset_fortran2003.html"},{"title":"lite_test – Fortran 2018 examples","text":"Calls program~~lite_test~~CallsGraph program~lite_test lite_test proc~test_datasets test_datasets program~lite_test->proc~test_datasets proc~test_attributes test_attributes program~lite_test->proc~test_attributes proc~test_dataset1d test_dataset1D program~lite_test->proc~test_dataset1d proc~test_dataset2d test_dataset2D program~lite_test->proc~test_dataset2d proc~test_dataset3d test_dataset3D program~lite_test->proc~test_dataset3d proc~passed passed proc~test_datasets->proc~passed h5ltread_dataset_double_f h5ltread_dataset_double_f proc~test_datasets->h5ltread_dataset_double_f h5ltget_dataset_info_f h5ltget_dataset_info_f proc~test_datasets->h5ltget_dataset_info_f h5ltmake_dataset_float_f h5ltmake_dataset_float_f proc~test_datasets->h5ltmake_dataset_float_f h5ltread_dataset_float_f h5ltread_dataset_float_f proc~test_datasets->h5ltread_dataset_float_f h5ltmake_dataset_string_f h5ltmake_dataset_string_f proc~test_datasets->h5ltmake_dataset_string_f h5ltget_dataset_ndims_f h5ltget_dataset_ndims_f proc~test_datasets->h5ltget_dataset_ndims_f h5fcreate_f h5fcreate_f proc~test_datasets->h5fcreate_f h5ltfind_dataset_f h5ltfind_dataset_f proc~test_datasets->h5ltfind_dataset_f h5fclose_f h5fclose_f proc~test_datasets->h5fclose_f h5close_f h5close_f proc~test_datasets->h5close_f proc~test_begin test_begin proc~test_datasets->proc~test_begin h5ltmake_dataset_int_f h5ltmake_dataset_int_f proc~test_datasets->h5ltmake_dataset_int_f h5ltread_dataset_int_f h5ltread_dataset_int_f proc~test_datasets->h5ltread_dataset_int_f h5open_f h5open_f proc~test_datasets->h5open_f h5ltmake_dataset_double_f h5ltmake_dataset_double_f proc~test_datasets->h5ltmake_dataset_double_f h5ltread_dataset_string_f h5ltread_dataset_string_f proc~test_datasets->h5ltread_dataset_string_f proc~test_attributes->proc~passed h5ltset_attribute_string_f h5ltset_attribute_string_f proc~test_attributes->h5ltset_attribute_string_f h5ltget_attribute_string_f h5ltget_attribute_string_f proc~test_attributes->h5ltget_attribute_string_f h5ltget_attribute_float_f h5ltget_attribute_float_f proc~test_attributes->h5ltget_attribute_float_f h5ltset_attribute_int_f h5ltset_attribute_int_f proc~test_attributes->h5ltset_attribute_int_f proc~test_attributes->h5fcreate_f proc~test_attributes->h5fclose_f proc~test_attributes->h5close_f h5ltget_attribute_ndims_f h5ltget_attribute_ndims_f proc~test_attributes->h5ltget_attribute_ndims_f proc~test_attributes->proc~test_begin proc~test_attributes->h5ltmake_dataset_int_f h5ltget_attribute_double_f h5ltget_attribute_double_f proc~test_attributes->h5ltget_attribute_double_f h5ltset_attribute_float_f h5ltset_attribute_float_f proc~test_attributes->h5ltset_attribute_float_f proc~test_attributes->h5open_f h5ltget_attribute_info_f h5ltget_attribute_info_f proc~test_attributes->h5ltget_attribute_info_f h5ltget_attribute_int_f h5ltget_attribute_int_f proc~test_attributes->h5ltget_attribute_int_f h5ltset_attribute_double_f h5ltset_attribute_double_f proc~test_attributes->h5ltset_attribute_double_f proc~test_dataset1d->proc~passed proc~test_dataset1d->h5fcreate_f proc~test_dataset1d->h5fclose_f proc~test_dataset1d->h5close_f proc~test_dataset1d->proc~test_begin h5ltmake_dataset_f h5ltmake_dataset_f proc~test_dataset1d->h5ltmake_dataset_f proc~test_dataset1d->h5open_f h5ltread_dataset_f h5ltread_dataset_f proc~test_dataset1d->h5ltread_dataset_f proc~test_dataset2d->proc~passed proc~test_dataset2d->h5fcreate_f proc~test_dataset2d->h5fclose_f proc~test_dataset2d->h5close_f proc~test_dataset2d->proc~test_begin proc~test_dataset2d->h5ltmake_dataset_f proc~test_dataset2d->h5open_f proc~test_dataset2d->h5ltread_dataset_f proc~test_dataset3d->proc~passed proc~test_dataset3d->h5ltget_dataset_info_f proc~test_dataset3d->h5fcreate_f proc~test_dataset3d->h5fclose_f proc~test_dataset3d->h5close_f proc~test_dataset3d->proc~test_begin proc~test_dataset3d->h5ltmake_dataset_f proc~test_dataset3d->h5open_f proc~test_dataset3d->h5ltread_dataset_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"program/lite_test.html"},{"title":"hdf5_hello – Fortran 2018 examples","text":"Uses hdf5 h5lt h5ds program~~hdf5_hello~~UsesGraph program~hdf5_hello hdf5_hello h5lt h5lt program~hdf5_hello->h5lt h5ds h5ds program~hdf5_hello->h5ds hdf5 hdf5 program~hdf5_hello->hdf5 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~hdf5_hello~~CallsGraph program~hdf5_hello hdf5_hello h5close_f h5close_f program~hdf5_hello->h5close_f h5open_f h5open_f program~hdf5_hello->h5open_f Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables error Variables Type Attributes Name Initial integer :: error","tags":"","loc":"program/hdf5_hello.html"},{"title":"print_vs_write – Fortran 2018 examples","text":"Uses iso_fortran_env program~~print_vs_write~~UsesGraph program~print_vs_write print_vs_write iso_fortran_env iso_fortran_env program~print_vs_write->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"program/print_vs_write.html"},{"title":"overwrite_stdout – Fortran 2018 examples","text":"Uses iso_c_binding iso_fortran_env program~~overwrite_stdout~~UsesGraph program~overwrite_stdout overwrite_stdout iso_fortran_env iso_fortran_env program~overwrite_stdout->iso_fortran_env iso_c_binding iso_c_binding program~overwrite_stdout->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~overwrite_stdout~~CallsGraph program~overwrite_stdout overwrite_stdout interface~usleep~2 usleep program~overwrite_stdout->interface~usleep~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i N Interfaces usleep Variables Type Attributes Name Initial integer :: i integer, parameter :: N = 5 Interfaces interface subroutine usleep(us) bind(c) Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: us","tags":"","loc":"program/overwrite_stdout.html"},{"title":"ascii – Fortran 2018 examples","text":"Contents None","tags":"","loc":"program/ascii.html"},{"title":"charlen – Fortran 2018 examples","text":"Contents Variables cb5 c5 ca Variables Type Attributes Name Initial character(len=5) :: cb5 character(len=5) :: c5 character(len=*), parameter :: ca (2) = 'hello'","tags":"","loc":"program/charlen.html"},{"title":"str2int – Fortran 2018 examples","text":"Uses iso_fortran_env program~~str2int~~UsesGraph program~str2int str2int iso_fortran_env iso_fortran_env program~str2int->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables M Variables Type Attributes Name Initial integer :: M","tags":"","loc":"program/str2int.html"},{"title":"special_char – Fortran 2018 examples","text":"Contents Variables nul etx tab backslash Variables Type Attributes Name Initial character, parameter :: nul = char(0) character, parameter :: etx = char(3) character, parameter :: tab = char(9) character, parameter :: backslash = char(92)","tags":"","loc":"program/special_char.html"},{"title":"splitstring – Fortran 2018 examples","text":"Uses iso_fortran_env program~~splitstring~~UsesGraph program~splitstring splitstring iso_fortran_env iso_fortran_env program~splitstring->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~splitstring~~CallsGraph program~splitstring splitstring proc~split split program~splitstring->proc~split Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables mystr stem Functions split Variables Type Attributes Name Initial character(len=*), parameter :: mystr = \"hello.txt\" character(len=:), allocatable :: stem Functions pure function split (instr, delm) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=1), intent(in) :: delm Return Value character(len=:),\n  allocatable","tags":"","loc":"program/splitstring.html"},{"title":"nulltest – Fortran 2018 examples","text":"Uses iso_fortran_env program~~nulltest~~UsesGraph program~nulltest nulltest iso_fortran_env iso_fortran_env program~nulltest->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables tic toc rate nulunix nulwin fout N ios u i tnul tscr Variables Type Attributes Name Initial integer(kind=int64) :: tic integer(kind=int64) :: toc integer(kind=int64) :: rate character(len=*), parameter :: nulunix = '/dev/null' character(len=*), parameter :: nulwin = 'NUL' character(len=*), parameter :: fout = 'out.txt' integer, parameter :: N = 1000 integer :: ios integer :: u integer :: i real :: tnul real :: tscr","tags":"","loc":"program/nulltest.html"},{"title":"terminal_io – Fortran 2018 examples","text":"Uses iso_fortran_env program~~terminal_io~~UsesGraph program~terminal_io terminal_io iso_fortran_env iso_fortran_env program~terminal_io->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables txt Variables Type Attributes Name Initial character(len=80) :: txt","tags":"","loc":"program/terminal_io.html"},{"title":"nulltest – Fortran 2018 examples","text":"Uses iso_fortran_env program~~nulltest~2~~UsesGraph program~nulltest~2 nulltest iso_fortran_env iso_fortran_env program~nulltest~2->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~nulltest~2~~CallsGraph program~nulltest~2 nulltest proc~writetime writetime program~nulltest~2->proc~writetime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables nulunix nulwin fout Nrun ios u tnul tscratch tfile Functions writetime Variables Type Attributes Name Initial character(len=*), parameter :: nulunix = '/dev/null' character(len=*), parameter :: nulwin = 'NUL' character(len=*), parameter :: fout = 'out.txt' integer, parameter :: Nrun = 1000 integer :: ios integer :: u real(kind=wp) :: tnul real(kind=wp) :: tscratch real(kind=wp) :: tfile Functions function writetime (u, Nrun) Arguments Type Intent Optional Attributes Name integer, intent(in) :: u integer, intent(in) :: Nrun Return Value real(kind=wp)","tags":"","loc":"program/nulltest~2.html"},{"title":"file_or_console – Fortran 2018 examples","text":"Uses iso_fortran_env program~~file_or_console~~UsesGraph program~file_or_console file_or_console iso_fortran_env iso_fortran_env program~file_or_console->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables filename buf i u Variables Type Attributes Name Initial character(len=:), allocatable :: filename character(len=256) :: buf integer :: i integer :: u","tags":"","loc":"program/file_or_console.html"},{"title":"home – Fortran 2018 examples","text":"Uses fsutils program~~home~~UsesGraph program~home home module~fsutils fsutils program~home->module~fsutils Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~home~~CallsGraph program~home home proc~expanduser expanduser program~home->proc~expanduser proc~homedir homedir proc~expanduser->proc~homedir Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables expanded buf Variables Type Attributes Name Initial character(len=:), allocatable :: expanded character(len=256) :: buf","tags":"","loc":"program/home.html"},{"title":"openreadonly – Fortran 2018 examples","text":"Uses iso_fortran_env program~~openreadonly~~UsesGraph program~openreadonly openreadonly iso_fortran_env iso_fortran_env program~openreadonly->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~openreadonly~~CallsGraph program~openreadonly openreadonly proc~deletefile deletefile program~openreadonly->proc~deletefile proc~createro createro program~openreadonly->proc~createro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables fnro Subroutines createro deletefile Variables Type Attributes Name Initial character(len=*), parameter :: fnro = 'ro.txt' Subroutines subroutine createro (fn) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn subroutine deletefile (fn) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fn","tags":"","loc":"program/openreadonly.html"},{"title":"noenv – Fortran 2018 examples","text":"Uses iso_fortran_env program~~noenv~~UsesGraph program~noenv noenv iso_fortran_env iso_fortran_env program~noenv->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables buf h ios Variables Type Attributes Name Initial character(len=4) :: buf integer :: h integer :: ios","tags":"","loc":"program/noenv.html"},{"title":"test_nan – Fortran 2018 examples","text":"Uses iso_fortran_env iso_fortran_env ieee_arithmetic program~~test_nan~~UsesGraph program~test_nan test_nan iso_fortran_env iso_fortran_env program~test_nan->iso_fortran_env ieee_arithmetic ieee_arithmetic program~test_nan->ieee_arithmetic Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables nan_sp nan_bit nan_dp ISP IDP Variables Type Attributes Name Initial real(kind=sp) :: nan_sp real(kind=sp) :: nan_bit real(kind=dp) :: nan_dp integer(kind=int32) :: ISP integer(kind=int64) :: IDP","tags":"","loc":"program/test_nan.html"},{"title":"huge_prec – Fortran 2018 examples","text":"Uses iso_fortran_env program~~huge_prec~~UsesGraph program~huge_prec huge_prec iso_fortran_env iso_fortran_env program~huge_prec->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables huge32 huge64 hugeint64 Variables Type Attributes Name Initial real(kind=real32), parameter :: huge32 = huge(1.0_real32) real(kind=real64), parameter :: huge64 = huge(1.0_real64) integer(kind=int64), parameter :: hugeint64 = huge(1_int64)","tags":"","loc":"program/huge_prec.html"},{"title":"prec – Fortran 2018 examples","text":"Uses iso_fortran_env program~~prec~~UsesGraph program~prec prec iso_fortran_env iso_fortran_env program~prec->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables huge32 huge64 hugeint64 imdouble J K Variables Type Attributes Name Initial real(kind=real32) :: huge32 = 9/5.0_real32 real(kind=real64) :: huge64 = 9/5.0_real64 integer(kind=int64) :: hugeint64 = 9/5_int64 real(kind=real64) :: imdouble = 9/5. integer(kind=int64) :: J integer(kind=int64) :: K","tags":"","loc":"program/prec.html"},{"title":"polymorphism – Fortran 2018 examples","text":"Uses iso_fortran_env program~~polymorphism~~UsesGraph program~polymorphism polymorphism iso_fortran_env iso_fortran_env program~polymorphism->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~polymorphism~~CallsGraph program~polymorphism polymorphism proc~timestwo~2 timestwo program~polymorphism->proc~timestwo~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables pi Functions timestwo Variables Type Attributes Name Initial real(kind=wp), parameter :: pi = 4._wp*atan(1._wp) Functions elemental function timestwo (a) result(a2) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Return Value real(kind=wp)","tags":"","loc":"program/polymorphism.html"},{"title":"float_prec – Fortran 2018 examples","text":"Uses iso_fortran_env program~~float_prec~~UsesGraph program~float_prec float_prec iso_fortran_env iso_fortran_env program~float_prec->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables pi32 pi64 Variables Type Attributes Name Initial real(kind=real32) :: pi32 = 4*atan(1.0_real32) real(kind=real64) :: pi64 = 4*atan(1.0_real64)","tags":"","loc":"program/float_prec.html"},{"title":"test2 – Fortran 2018 examples","text":"Uses funcs program~~test2~~UsesGraph program~test2 test2 module~funcs funcs program~test2->module~funcs iso_fortran_env iso_fortran_env module~funcs->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~test2~~CallsGraph program~test2 test2 interface~addtwo addtwo program~test2->interface~addtwo proc~addtwo_i addtwo_i interface~addtwo->proc~addtwo_i proc~addtwo_s addtwo_s interface~addtwo->proc~addtwo_s proc~addtwo_d addtwo_d interface~addtwo->proc~addtwo_d Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables twos twod twoi Variables Type Attributes Name Initial real(kind=sp) :: twos = 2._sp real(kind=dp) :: twod = 2._dp integer :: twoi = 2","tags":"","loc":"program/test2.html"},{"title":"precision_problems – Fortran 2018 examples","text":"Uses iso_fortran_env program~~precision_problems~~UsesGraph program~precision_problems precision_problems iso_fortran_env iso_fortran_env program~precision_problems->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables me mebad Variables Type Attributes Name Initial real(kind=wp), parameter :: me = 9.10938356e-31_wp real(kind=wp), parameter :: mebad = 9.10938356_wp*10**(-31)","tags":"","loc":"program/precision_problems.html"},{"title":"testall – Fortran 2018 examples","text":"Uses ieee_arithmetic iso_fortran_env fib3 assert program~~testall~~UsesGraph program~testall testall iso_fortran_env iso_fortran_env program~testall->iso_fortran_env module~assert assert program~testall->module~assert ieee_arithmetic ieee_arithmetic program~testall->ieee_arithmetic module~fib3 fib3 program~testall->module~fib3 module~assert->iso_fortran_env module~assert->ieee_arithmetic module~fib3->module~assert iso_c_binding iso_c_binding module~fib3->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~testall~~CallsGraph program~testall testall proc~isclose isclose program~testall->proc~isclose proc~assert_isclose assert_isclose program~testall->proc~assert_isclose proc~fib FIB program~testall->proc~fib proc~assert_isclose->proc~isclose Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables pi nan inf Variables Type Attributes Name Initial real(kind=wp), parameter :: pi = 4.*atan(1._wp) real(kind=wp) :: nan real(kind=wp) :: inf","tags":"","loc":"program/testall.html"},{"title":"wait_precision – Fortran 2018 examples","text":"Uses iso_fortran_env program~~wait_precision~~UsesGraph program~wait_precision wait_precision iso_fortran_env iso_fortran_env program~wait_precision->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~wait_precision~~CallsGraph program~wait_precision wait_precision proc~timempi timempi program~wait_precision->proc~timempi omp_get_wtick omp_get_wtick proc~timempi->omp_get_wtick omp_get_wtime omp_get_wtime proc~timempi->omp_get_wtime omp_get_num_procs omp_get_num_procs proc~timempi->omp_get_num_procs omp_get_num_threads omp_get_num_threads proc~timempi->omp_get_num_threads omp_get_thread_num omp_get_thread_num proc~timempi->omp_get_thread_num Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables tic toc rate Subroutines timempi Variables Type Attributes Name Initial integer(kind=int64) :: tic integer(kind=int64) :: toc integer(kind=int64) :: rate Subroutines subroutine timempi () Arguments None","tags":"","loc":"program/wait_precision.html"},{"title":"AckermannPeter – Fortran 2018 examples","text":"Uses Ackp program~~ackermannpeter~~UsesGraph program~ackermannpeter AckermannPeter module~ackp Ackp program~ackermannpeter->module~ackp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~ackermannpeter~~CallsGraph program~ackermannpeter AckermannPeter proc~ap Ap program~ackermannpeter->proc~ap proc~ap->proc~ap Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Ack M N buf Variables Type Attributes Name Initial integer :: Ack integer :: M integer :: N character(len=8) :: buf","tags":"","loc":"program/ackermannpeter.html"},{"title":"mysound – Fortran 2018 examples","text":"Uses iso_fortran_env program~~mysound~~UsesGraph program~mysound mysound iso_fortran_env iso_fortran_env program~mysound->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables playexe cmdopts fn pcmd ios Variables Type Attributes Name Initial character(len=*), parameter :: playexe = 'ffplay' character(len=*), parameter :: cmdopts = '-autoexit -loglevel quiet -nodisp' character(len=1000) :: fn character(len=1000) :: pcmd integer :: ios","tags":"","loc":"program/mysound.html"},{"title":"gitrev – Fortran 2018 examples","text":"Calls program~~gitrev~~CallsGraph program~gitrev gitrev proc~log_gitrev log_gitrev program~gitrev->proc~log_gitrev Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"program/gitrev.html"},{"title":"intel_svd – Fortran 2018 examples","text":"Uses iso_fortran_env program~~intel_svd~~UsesGraph program~intel_svd intel_svd iso_fortran_env iso_fortran_env program~intel_svd->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~intel_svd~~CallsGraph program~intel_svd intel_svd dgesvd dgesvd program~intel_svd->dgesvd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables A svdinfo M N Lratio LWORK U VT SWORK ss64 s64 e64 maxerr s64ref Variables Type Attributes Name Initial real(kind=dp) :: A (3,3) = reshape([1, 0, 1, -1, -2, 0, 0, 1, -1], shape(A)) integer :: svdinfo integer, parameter :: M = size(a, 1) integer, parameter :: N = size(a, 2) integer, parameter :: Lratio = 5 integer, parameter :: LWORK = LRATIO*M real(kind=dp) :: U (M,M) real(kind=dp) :: VT (M,M) real(kind=dp) :: SWORK (LRATIO*M) real(kind=dp) :: ss64 (M,N) real(kind=dp) :: s64 (M) real(kind=dp) :: e64 (M) real(kind=dp) :: maxerr real(kind=dp), parameter :: s64ref (3) = [2.460504870018764_dp, 1.699628148275318_dp, 0.239123278256554_dp]","tags":"","loc":"program/intel_svd.html"},{"title":"rot90_array – Fortran 2018 examples","text":"Uses rotflip program~~rot90_array~~UsesGraph program~rot90_array rot90_array module~rotflip rotflip program~rot90_array->module~rotflip iso_fortran_env iso_fortran_env module~rotflip->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~rot90_array~~CallsGraph program~rot90_array rot90_array proc~printarr printarr program~rot90_array->proc~printarr interface~fliplr fliplr program~rot90_array->interface~fliplr interface~rot90 rot90 program~rot90_array->interface~rot90 interface~flipud flipud program~rot90_array->interface~flipud proc~fliplr_r fliplr_r interface~fliplr->proc~fliplr_r proc~fliplr_i fliplr_i interface~fliplr->proc~fliplr_i proc~rot90_i rot90_i interface~rot90->proc~rot90_i proc~rot90_r rot90_r interface~rot90->proc~rot90_r proc~flipud_i flipud_i interface~flipud->proc~flipud_i proc~flipud_r flipud_r interface~flipud->proc~flipud_r interface~flip flip proc~rot90_i->interface~flip proc~rot90_r->interface~flip proc~flipud_i->interface~flip proc~fliplr_r->interface~flip proc~flipud_r->interface~flip proc~fliplr_i->interface~flip proc~flip_r flip_r interface~flip->proc~flip_r proc~flip_i flip_i interface~flip->proc~flip_i Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables N i iarr Barr rarr Subroutines printarr Variables Type Attributes Name Initial integer, parameter :: N = 3 integer :: i integer :: iarr (N,N) integer :: Barr (0:2,0:2) real :: rarr (N,N) Subroutines subroutine printarr (arr, msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: arr (:,:) character(len=*), intent(in), optional :: msg","tags":"","loc":"program/rot90_array.html"},{"title":"intel_svd – Fortran 2018 examples","text":"Uses lapack95 iso_fortran_env program~~intel_svd~2~~UsesGraph program~intel_svd~2 intel_svd iso_fortran_env iso_fortran_env program~intel_svd~2->iso_fortran_env lapack95 lapack95 program~intel_svd~2->lapack95 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~intel_svd~2~~CallsGraph program~intel_svd~2 intel_svd gesvd gesvd program~intel_svd~2->gesvd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables A M N s64 e64 maxerr s32 a32 e32 Variables Type Attributes Name Initial real(kind=dp) :: A (3,3) = reshape([1, 0, 1, -1, -2, 0, 0, 1, -1], shape(A)) integer, parameter :: M = size(a, 1) integer, parameter :: N = size(a, 2) real(kind=dp) :: s64 (M) real(kind=dp) :: e64 (M) real(kind=dp) :: maxerr real(kind=sp) :: s32 (M) real(kind=sp) :: a32 (M,N) real(kind=sp) :: e32 (M)","tags":"","loc":"program/intel_svd~2.html"},{"title":"submod_demo – Fortran 2018 examples","text":"Uses iso_fortran_env points program~~submod_demo~~UsesGraph program~submod_demo submod_demo module~points~2 points program~submod_demo->module~points~2 iso_fortran_env iso_fortran_env program~submod_demo->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~submod_demo~~CallsGraph program~submod_demo submod_demo interface~point_dist point_dist program~submod_demo->interface~point_dist proc~point_dist point_dist interface~point_dist->proc~point_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a b dist Variables Type Attributes Name Initial type( point ) :: a type( point ) :: b real :: dist","tags":"","loc":"program/submod_demo.html"},{"title":"submod_demo – Fortran 2018 examples","text":"Uses iso_fortran_env points program~~submod_demo~2~~UsesGraph program~submod_demo~2 submod_demo module~points~2 points program~submod_demo~2->module~points~2 iso_fortran_env iso_fortran_env program~submod_demo~2->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~submod_demo~2~~CallsGraph program~submod_demo~2 submod_demo interface~point_dist point_dist program~submod_demo~2->interface~point_dist proc~point_dist point_dist interface~point_dist->proc~point_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dist ax ay bx by Variables Type Attributes Name Initial real :: dist real :: ax real :: ay real :: bx real :: by","tags":"","loc":"program/submod_demo~2.html"},{"title":"sm – Fortran 2018 examples","text":"Uses demod program~~sm~~UsesGraph program~sm sm module~demod demod program~sm->module~demod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~sm~~CallsGraph program~sm sm interface~hello hello program~sm->interface~hello proc~hello hello interface~hello->proc~hello Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"program/sm.html"},{"title":"submod_demo – Fortran 2018 examples","text":"Uses iso_fortran_env points program~~submod_demo~3~~UsesGraph program~submod_demo~3 submod_demo module~points~2 points program~submod_demo~3->module~points~2 iso_fortran_env iso_fortran_env program~submod_demo~3->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~submod_demo~3~~CallsGraph program~submod_demo~3 submod_demo interface~point_dist point_dist program~submod_demo~3->interface~point_dist proc~point_dist point_dist interface~point_dist->proc~point_dist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a b dist Variables Type Attributes Name Initial type( point ) :: a type( point ) :: b real :: dist","tags":"","loc":"program/submod_demo~3.html"},{"title":"a – Fortran 2018 examples","text":"Contents None","tags":"","loc":"program/a.html"}]}